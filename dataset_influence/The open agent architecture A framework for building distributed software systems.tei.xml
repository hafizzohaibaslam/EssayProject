<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 D:\grobid-master\grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.1-SNAPSHOT" ident="GROBID" when="2018-07-17T00:07+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The open agent architecture: A framework for building distributed software systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher>Informa UK Limited</publisher>
				<availability status="unknown"><p>Copyright Informa UK Limited</p>
				</availability>
				<date type="published" when="2010-11-26">Published online: 26 Nov 2010. Date: 19 September 2016, At: 17:54</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">L</forename><surname>Martin</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><forename type="middle">J</forename><surname>Cheyer</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Douglas</forename><forename type="middle">B</forename><surname>Moran</surname></persName>
						</author>
						<title level="a" type="main">The open agent architecture: A framework for building distributed software systems</title>
					</analytic>
					<monogr>
						<title level="j" type="main">Applied Artificial Intelligence</title>
						<title level="j" type="abbrev">Applied Artificial Intelligence</title>
						<idno type="ISSN">0883-9514</idno>
						<idno type="eISSN">1087-6545</idno>
						<imprint>
							<publisher>Informa UK Limited</publisher>
							<biblScope unit="volume">13</biblScope>
							<biblScope unit="issue">1-2</biblScope>
							<biblScope unit="page" from="91" to="128"/>
							<date type="published" when="2010-11-26">Published online: 26 Nov 2010. Date: 19 September 2016, At: 17:54</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1080/088395199117504</idno>
					<note>(Online) Journal homepage: http://www.tandfonline.com/loi/uaai20 To cite this article: David L. Martin , Adam J. Cheyer &amp; Douglas B. Moran (1999) The open agent architecture: A framework for building distributed software systems, Applied Artificial Intelligence, 13:1-2, 91-128, To link to this article: http://dx. Submit your article to this journal Article views: 166 View related articles Citing articles: 120 View citing articles Full Terms &amp; Conditions of access and use can be found at Download by: [Auckland University of Technology]</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TECHN OLOGIES F OR DISTRIBUTED COM PUTIN G</head><p>We brie? y review the overall concepts, advantages, and disadvantages of several relevant approaches to distributed computing, including distributed objects, mobile objects, blackboard-style architectures, and agent-based software engineering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Distributed Object Approach</head><p>Object-oriented languages, such as or JAVA, provide signi? cant C1 1 advances over standard procedural languages with respect to the reusability and modularity of code:</p><p>encourages the creation of library interfaces that minimize d Encapsulation dependencies on underlying algorithms or data structures. Changes to programming internals can be made at a later date without requiring modi? cations to the code that uses the library.</p><p>permits the extension and modi? cation of a library of routines Whereas ''standard'' object-oriented programming (OOP ) languages can be used to build monolithic programs out of many object building blocks, distributed object technologies (DOOP ) such as Olyect M anagement Group's (OM G's) CORBA (OM G, 1997) or M icrosoft's DCOM <ref type="bibr">(M icrosoft, 1996)</ref> allow the creation of programs whose components may be spread across multiple machines. To implement a client-server relationship between objects, distributed object systems use a registry mechanism (CORBA's registry is called an Object Request Broker, or ORB) to store the interface descriptions of available objects. Through the ORB's services, a client can transparently invoke a method on a remote server object ; the ORB is responsible for ? nding an object that can implement the request, passing it the parameters, invoking its method, and returning the results. The client does not have to be aware of where the object is located, its programming language, its operating system, or any other system aspects that are not part of an object's interface. Although distributed objects o er a powerful paradigm for creating networked applications, certain aspects of the approach are not perfectly tailored to the constantly changing environment of the Internet. A major restriction of the DOOP approach is that the interactions among objects are ? xed through explicitly coded instructions by the application developer. This implies that it is very difficult to reuse an object in a new application without bringing along all its inherent dependencies on other objects (embedded interface de? nitions and explicit method calls). Another restriction of the DOOP approach is the result of its reliance on a remote procedure call (RPC) style of communication. Although easy to debug, this single thread of execution model does not facilitate programming to exploit the potential for parallel computation that one would expect in a distributed environment. In addition, RPC uses a blocking (synchronous) scheme that does not scale well for high-volume transactions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M obile Objects</head><p>M obile objects, sometimes called mobile agents, are bits of code that can move to another execution site (presumably on a di erent machine) under their own programmat ic control, where they can then efficiently interact with the local environment. Commercial instantiations of this technology include Aglets from IBM , Concordia from M itsubishi, and Voyager from ObjectSpace.</p><p>For certain types of problems, the mobile object paradigm o ers advantages over more traditional distributed object approaches. These advantages include bandwidth : for some database queries or electronic commerce d N etwork applications, it is more efficient to perform tests on data by bringing the tests to the data than by bringing large amounts of data to the testing program.</p><p>mobile agents can be spawned in parallel to accomplish d P arallelism : many tasks at once.</p><p>Disadvantages (or inconveniences) of the mobile agent approach are that a fashion similar to that of DOOP programming, an agent developer <ref type="table">d   In  must programmat ically specify where to go and how to interact with the  target environment.  is generally little coordination support to encourage</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Blackboard Architectures</head><p>Blackboard approaches, such as Schwartz's FLiP SiDE (Schwartz, 1995) or Gelernter's LIN DA <ref type="bibr" target="#b6">(Gelernter, 1993)</ref>, allow multiple processes to communicate by reading and writing tuples from a global data store. Each process can watch for items of interest, perform computations based on the state of the blackboard, and then add partial results or queries that other processes can consider.</p><p>Blackboard architectures provide a ? exible framework for problem solving by a dynamic community of distributed processes. A blackboard approach provides one solution to eliminating the tightly bound interaction links that some of the other distributed technologies require during interprocess communication. This advantage can also be a disadvantage : although a programmer does not need to refer to a speci? c process during computation, the framework does not provide programmatic control for doing so in cases where this would be practical.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Agent-Based Software Engineering</head><p>Several research communities have approached distributed computing by casting it as a problem of modeling communication and cooperation among autonomous entities. E ective communication among independent actors requires four components : (1) a transport mechanism carrying messages in an asynchronous fashion, (2) an interaction protocol de? ning various types of communication interchange and their social implications (for instance, a response is expected of a question), (3) a content language permitting the expression and interpretation of utterances, and (4) an agreed-upon set of shared vocabulary and meaning for concepts (often called an ontology). Such mechanisms permit a much richer style of interaction among participants than can be expressed using a distributed object's RPC model or a blackboard architecture's centralized exchange approach.</p><p>Undoubtedly, the most widely used foundation technology for agentbased software engineering is the K nowledge Query and M anipulation Language (KQM L) <ref type="bibr">F inin et al., 1997)</ref>. KQM L, which speci? es an interaction protocol, is often used in conjunction with the Knowledge Interchange Format (KIF) <ref type="bibr">(Genesereth &amp; F ikes, 1992)</ref> as content language, and either ad hoc or more formalized ontologies. K QM L introduced the use of symbolic performatives to capture information about the purpose of a communication and its place within a conversation. Although creating a standardized representation for conversational interactions is one important aspect of multiagent cooperation, KQM L is limited by its reliance on a ? xed core set of atomic performatives and the inevitable difficulty in arriving at just the right set capable of expressing every kind interaction and service request.</p><p>Another in? uential approach, which makes stronger assumptions about the knowledge and processing used within individual agents, is based on the structuring of the agents' activities around the concepts of Belief, Desire, and Intention (BDI) <ref type="bibr" target="#b18">(Rao &amp; George , 1995)</ref>. While BDI's emphasis on a higher level of abstraction has been extremely important in giving direction to work on agent-based systems, its applicability may be limited by the structural requirements imposed on individual agents and by difficulties in interoperating with legacy systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PHILOSOPHY AN D GOALS OF OAA</head><p>Our approach to distributed computing shares much in common with the paradigms outlined above. As with distributed object frameworks, the primary goals of OAA is to provide a means for integrating heterogeneous applications in a distributed infrastructure. However, we have also sought to incorporate some of the dynamism and extensibility of blackboard approaches, the efficiency associated with mobile objects, and the rich and complex interactions of communicating agents. Here, we spell out in greater detail the goals of OAA, which may be categorized under the general headings of interoperation and cooperation, user interfaces, and software engineering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Versatile M echanisms of Interoperation and Cooperation</head><p>Interoperation refers to the ability of distributed software components? agents? to communicate meaningfully. While every system-building frame-work must provide mechanisms of interoperation at some level of granularity, agent-based frameworks face important new challenges in this area. This is true primarily because autonomy, the hallmark of individual agents, necessitates greater ? exibility in interactions within communities of agents. Coordination refers to the mechanisms by which a community of agents is able to work together productively on some task. In these areas, the goals for our framework are to in assembling communities of autonomous service d Provide providers? both at development time and at runtime. Agents that conform to the linguistic and ontological requirements for e ective communication should be able to participate in an agent community, in various combinations, with minimal prerequisite knowledge of the characteristics of the other players. Agents with duplicate and overlapping capabilities should be able to coexist within the same community, with the system making the best possible use of the redundancy.</p><p>in structuring cooperative interactions among the d Provide members of a community of agents. A framework should provide economical means of setting up a variety of interaction patterns among agents, without requiring an inordinate amount of complexity or infrastructure within the individual agents. The provision of a service should not be dependent upon a particular con? guration of agents. the right amount of structure on individual agents. Di erent d Impose approaches to the construction of multiagent systems impose di erent requirements on the individual agents. F or example, because K QM L is neutral as to the content of messages, it imposes minimal structural requirements on individual agents. On the other hand, the BDI paradigm is likely to impose much more demanding requirements because it makes assumptions about the nature of the programming elements that are meaningful to individual agents. OAA falls somewhere between the two ; our goal has been to provide a rich set of interoperation and coordination mechanisms but without precluding any of the software engineering goals de? ned below. legacy and ''owned-elsewhere'' applications. Whereas legacy usually d Include implies reuse of an established system fully controlled by the agent-based system developer, owned-elsewhere refers to applications to which the developer has partial access but no control. Examples of the latter are data sources and services available on the World Wide Web, via simple form-based interfaces, and applications used cooperatively within a virtual enterprise, which remain the property of separate corporate entities. It must be possible for both classes of application to interoperate, more or less as full-? edged members of the agent community, without requiring an overwhelming integration e ort.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Human-Oriented User Interfaces</head><p>Systems composed of multiple distributed components, and possibly dynamic con? gurations of components, require the crafting of intuitive user interfaces to conceptually natural means of interacting with multiple distribd P rovide uted components. When there are numerous disparate agents, and/ or complex tasks implemented by the system, the user should be able to express requests without having detailed knowledge of the individual agents. With speech recognition, handwriting recognition, and natural language technologies becoming more mature, an agent architecture must be prepared for these forms of input to play an increased role in the tasking of agent communities.</p><p>users as privileged members of the agent community. By providing d</p><p>Treat an appropriate level of task speci? cation within software agents, and reusable means of translating between this level and the level of human requests, it should be possible to construct interactions that seamlessly incorporate both types of ''agent.'' collaboration (simultaneous work over shared data and pro- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Realistic Software Engineering Requirements</head><p>To be successful, a system-building framework must address the practical concerns of real-world applications, as expressed by these goals : the e ort required to create new agents and to wrap existing</p><formula xml:id="formula_0">d M inimize applications.</formula><p>reuse, both of domain-independent and domain-speci? c com- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>OVERVIEW OF OAA</head><p>In this section, we present an overview of OAA, ? rst describing the basic components and structure of the framework, and then illustrating these concepts with a sample application. <ref type="figure">Figure 1</ref> presents the structure typical of a small OAA system, showing a user interface agent and several application agents and meta-agents, organized as a community of peers by their common relationship to a facilitator agent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>OAA System Structure</head><p>The facilitator is a specialized server agent that is responsible for coordinating agent communications and cooperative problem solving. In many systems the facilitator is also used to provide a global data store for its client agents, which allows them to adopt a blackboard style of interaction. Note that a system con? guration is not limited to a single facilitator. Larger systems can be assembled from multiple facilitator/ client groups, each having the sort of structure shown in <ref type="figure">Figure 1</ref>.</p><p>The other categories of agents illustrated here? application agents, meta-agents, and user interface agents? are categories recognized by convention only ; that is, they are not formally distinguished within the system. Application agents are usually specialists that provide a collection of services of a particular sort. These services could be domain-independent technologies (such as speech recognition, natural language processing, e-mail, and some forms of data retrieval and data mining) or user speci? c or domain speci? c (such as a travel planning and reservations agent). Application agents may be based on legacy applications or libraries, in which case the agent may be little more than a wrapper that calls a preexisting API.</p><p>M eta-agents are those whose role is to assist the facilitator agent in coordinating the activities of other agents. While the facilitator possesses domain-independent coordination strategies, meta-agents can augment these by using domain-and application-speci? c knowledge or reasoning (rules, learning algorithms, planning, and so forth).</p><p>The user interface agent plays an extremely important and interesting role in many OAA systems. In some systems this agent is implemented as a collection of ''micro-agents,'' each monitoring a di erent input modality (point-and-click, handwriting, pen gestures, speech), and collaborating to produce the best interpretation of the current inputs. These micro-agents are shown in <ref type="figure">Figure 1</ref> as M odality Agents.</p><p>All agents that are not facilitators are referred to as client agents? so called because each acts (in some respects) as a client of some facilitator, which provides communication and other essential services for the client. When invoked, a client agent makes a connection to a facilitator, which is known as its parent facilitator. Upon connection, an agent informs its parent facilitator of the services it can provide. When the agent is needed, the facilitator sends it a request expressed in the Interagent Communication Language (ICL). The agent parses this request, processes it, and returns answers or status reports to the facilitator. In processing a request, the agent can make use of a variety of capabilities provided by OAA. F or example, it can use ICL to request services of other agents, set triggers, and read or write shared data on the facilitator (or other client agents that maintain shared data).</p><p>The common infrastructure for constructing agents is supplied by an agent library, which is available in several di erent programming languages. The library has been designed to minimize the e ort required to construct a new system and to maximize the ease with which legacy systems can be agenti? ed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sample Interactions</head><p>Perhaps the best way to obtain an intuitive sense of how the OAA typically functions is to brie? y look at an example of how OAA has been applied to a real application. In the Automated Office system, a mobile executive with a telephone and a laptop computer can access and task commercial applications such as calendars, databases, and e-mail systems running back at the office. As depicted in <ref type="figure" target="#fig_2">Figure 2</ref>, an application agent provides a wrapper for each program, making its functionality and natural language vocabulary available to the agent community through registration with a facilitator. A user interface (UI) agent, shown in <ref type="figure" target="#fig_3">Figure 3</ref>, runs on the user's local laptop and is responsible for accepting user input, sending requests to the facilitator for delegation to appropriate agents, and displaying the results of the distributed computation. The user may interact directly with a speci? c remote application by clicking on active areas in the interface, calling up a form or window for that application, and making queries with standard interface dialog mechanisms. Conversely, a user may express a task to be executed by using typed, handwritten, or spoken (over the telephone) English sentences, without explicitly specifying which agent or agents should perform the task. For instance, if the question, ''What is my schedule ?'' is written in the user interface, this request will be sent by the UI to the facilitator, which in turn, will ask a natural language (N L) agent to translate the query into ICL. To accomplish this task, the NL agent may itself need to make requests of the agent community to resolve unknown words such as ''me'' (the UI agent can respond with the name of the current user) or ''schedule'' (the calendar agent de? nes this word). The resulting ICL expression is then routed by the facilitator to appropriate agents (in this case, the calendar agent) to execute the request. Results are sent back to the UI agent for display.</p><p>The spoken request, ''When mail arrives for me about security, notify me immediately'' produces a slightly more complex example involving communication among all agents in the system. After translation into ICL as described above, the facilitator installs a trigger on the mail agent to look for new messages about security. When one such message does arrive in its mail spool, the trigger ? res, and the facilitator matches the action part of the trigger to capabilities published by the noti? cation agent. The noti? cation agent is an example of a meta-agent, as it makes use of rules concerning the optimal use of di erent output modalities (e-mail, fax, speech generation over the telephone) plus information about an individual user's preferences to determine the best way of relaying a message through available media transfer application agents. After some competitive parallelism to locate the user (the calendar and database agents may have di erent guesses as to where to ? nd the user) and some cooperative parallelism to produce required information (telephone number of location, user password, and an audio ? le containing a text-to-speech representation of the e-mail message), a telephone agent can call the user, verify identity through touchtones, and then play the message.</p><p>Some key ideas illustrated by the above examples are the following :</p><p>2. The interpretation and execution of a task is a distributed process, with no one agent de? ning the set of possible inputs to the system. 3. A single request can produce cooperation and ? exible communication among many agents, written in di erent programming languages and spread across multiple machines.</p><p>In our following detailed view of the Open Agent Architecture, we order the presentation top-down, beginning with the means by which a group of agents works together, then considering the mechanisms that support the use of shared data repositories and triggers, and ? nally, describing some of the basic infrastructure underlying the construction of individual agents. To illustrate the technical aspects of the approach, we describe several applications implemented within the OAA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M ECHAN ISM S OF COOPERATION</head><p>Cooperation among the agents of an OAA system is achieved via messages expressed in a common language, ICL, and is normally structured around a three-part approach : providers of services register capabilities speci? cations with a facilitator, requesters of services construct goals and relay them to a facilitator, and facilitators coordinate the e orts of the appropriate service providers in satisfying these goals.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Interagent Communication Language</head><p>OAA's Interagent Communication Language (ICL) is the interface, communication, and task coordination language shared by all agents, regardless of what platform they run on or what computer language they are programmed in. ICL is used by an agent to task itself or some subset of the agent community, either using explicit control or, more frequently, in an underspeci? ed, loosely constrained manner. OAA agents employ ICL to perform queries, execute actions, exchange information, set triggers, and manipulate data in the agent community.</p><p>One of the fundamental program elements expressed in ICL is the event. The activities of every agent, as well as communications between agents, are structured around the transmission and handling of events. In communications, events serve as messages between agents ; in regulating the activities of individual agents, they may be thought of as goals to be satis? ed.</p><p>Each event has a type, a set of parameters, and content. For example, the agent library procedure oaa -Solve can be used by an agent to request services of other agents. A call to oaa -Solve, within the code of agent A, results in an event having the form going from A to the facilitator, where ev -post -solve is the type, Goal is the content, and Params is a list of parameters. The allowable content and parameters vary according to the type of the event.</p><p>The ICL includes a layer of conversational protocol, similar in spirit to that provided by K QM L, and a content layer, analogous to that provided by K IF . The conversational layer of ICL is de? ned by the event types, together with the parameter lists associated with certain of these event types. The content layer consists of the speci? c goals, triggers, and data elements that may be embedded within various events.</p><p>The conversational protocol is speci? ed using an orthogonal, parameterized approach. That is, the conversational aspects of each element of an interagent conversation are represented by a selection of an event type, in combination with a selection of values for an orthogonal set of parameters. This approach o ers greater expressiveness than an approach based solely on a ? xed selection of speech acts, such as embodied in K QM L. F or example, in KQM L, a request to satisfy a query can employ either of the performatives ask -all or ask -one. In ICL, on the other hand, this type of request is expressed by the event type ev -post -solve, together with the solution -limit(N) parameter? where N can be any positive integer. (A request for all solutions is indicated by the omission of the solution -limit parameter.) The request can also be accompanied by other parameters, which combine to further re? ne its semantics.</p><p>In KQM L, then, this example forces one to choose between two possible conversational options, neither of which may be precisely what is desired. In either case, the performative chosen is a single value that must capture the entire conversational characterization of the communication. This requirement raises a difficult challenge for the language designer, to select a set of performatives that provides the desired functionality without becoming unmanageably large. Consequently, the debate over the right set of performatives has consumed much discussion within the KQM L community.</p><p>The content layer of the ICL has been designed as an extension of the PROLOG programming language, to take advantage of uni? cation and other features of PROLOG. OAA's agent libraries (especially the non-PROLOG versions) provide support for constructing, parsing, and manipulating ICL expressions.</p><p>While it is possible to embed content expressed in other languages within an ICL event, it is advantageous to express content in ICL wherever possible. The primary reason for this is to allow the facilitator access to the content, as well as the conversational layer, in delegating requests. N ot only does this give the facilitator more information about the nature of a request, but it also makes it possible for the facilitator to decompose compound requests, and individually delegate the subrequests.</p><p>Important declarations and other program elements represented using ICL expressions include, in addition to events, capabilities declarations, requests for services, responses to requests, trigger speci? cations, and shared data elements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Providing Services</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Overview</head><p>Every agent participating in an OAA-based system de? nes and publishes a set of capabilities declarations, expressed in ICL, describing the services that it provides. These declarations establish a high-level interface to the agent. This interface is used by a facilitator in communicating with the agent and, most important, in delegating service requests (or parts of requests) to the agent. P artly due to the use of P ROLOG as the basis of ICL, we refer to these capabilities declarations as solvables.</p><p>Two major types of solvables are distinguished : procedure solvables and data solvables. Intuitively, a procedure solvable performs a test or action, whereas a data solvable provides access to a collection of data. F or example, in creating an agent for a mail system, procedure solvables might be de? ned for sending a message to a person, testing whether a message about a particular subject has arrived in the mail queue, or displaying a particular message on-screen. For a database wrapper agent, one might de? ne a distinct data solvable corresponding to each of the relations present in the database. Often, a data solvable is used to provide a shared data store, which may be not only queried, but also updated, by various agents having the required permissions.</p><p>Technically, the primary di erences between the two types of solvables are these : First, each procedure solvable must have a handler declared and de? ned for it, whereas this is not necessary for a data solvable. (The handling of requests for a data solvable is provided transparently by the agent library.) Second, data solvables are associated with a dynamic collection of facts (or clauses), which may be modi? ed at runtime, both by the agent providing the solvable and by other agents (provided they have the required permissions). Third, special features, available for use with data solvables, facilitate maintaining the associated facts. Some of these features are mentioned in the section below, M aintaining Data Repositories.</p><p>In spite of these di erences, it should be noted that the means of use (that is, the means by which an agent requests a service) is the same for the two types of solvables. Requesting of services is described in the section below, Requesting Services.</p><p>A request for one of an agent's services normally arrives in the form of an event from the agent's facilitator. The appropriate handler then deals with this event. The handler may be coded in whatever fashion is most appropriate, depending on the nature of the task, and the availability of task-speci? c libraries or legacy code, if any. The only hard requirement is that the handler return an appropriate response to the request, expressed in ICL. Depending on the nature of the request, this response could be an indication of success or failure, or a list of solutions (when the request is a data query).</p><p>The agent library provides a set of procedures allowing an agent to add, remove, and modify its solvables, which it may do at any time after connecting to its facilitator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Speci of Solvables</head><p>A solvable has three parts : a goal, a list of permissions, and a list of parameters, which are declared using the format</p><formula xml:id="formula_1">solvable (Goal, Parameters, Permissions)</formula><p>The goal of a solvable, which syntactically takes the form of an ICL structure, is a logical representation of the service provided by the solvable. (An ICL structure consists of a functor with 0 or more arguments. F or example, in the structure a(b,c), ''a'' is the functor, and ''b'' and ''c'' are the arguments.) As with a P ROLOG structure, the goal's arguments may themselves be structures.</p><p>Various options can be included in the parameters list, to re? ne the semantics associated with the solvable. F irst and foremost, the type parameter is used to say whether the solvable is data or procedure. When the type is procedure, another parameter may be used to indicate the handler to be associated with the solvable. Some of the parameters appropriate for a data solvable are mentioned in the section below, M aintaining Data Repositories.</p><p>In either case (procedure or data solvable), the private parameter may be used to restrict the use of a solvable to the declaring agent. This parameter is valuable when the agent intends the solvable to be solely for its internal use and wants to take advantage of OAA mechanisms in accessing it, or when the agent wants the solvable to be available to outside agents only at selected times. In support of the latter case, it is possible for the agent to change the status of a solvable from private to nonprivate at any time.</p><p>The permissions of a solvable provide the means by which an agent may control access to its services. They allow the agent to restrict calling and writing of a solvable to itself and/or other selected agents. (Calling means requesting the service encapsulated by a solvable, whereas writing means modifying the collection of facts associated with a data solvable.) The default is for every solvable to be callable by anyone and for data solvables to be</p><note type="other">writable by anyone. A solvable's permissions can be changed at any time, by the agent providing the solvable.</note><p>For example, the solvables of a simple e-mail agent might include</p><formula xml:id="formula_2">solvable(send -message(email,+ToPerson, +Params), [type(procedure), callback(send -mail)] []) solvable(last -message(email, -MessageId),</formula><p>[type(data), single -value(true)], [write(true)]), solvable(get -message(email,+MessageId, -Msg),</p><p>[type(procedure), callback(get -mail)], []).</p><p>The symbols 1 and2 , indicating input and output arguments, are at present used only for purposes of documentation. M ost parameters and permissions have default values, and speci? cations of default values may be omitted from the parameters and permissions lists.</p><p>A programmer who de? nes an agent's capabilities in terms of solvable declarations is, in a sense, creating the vocabulary with which other agents will communicate with the new agent. The problem of ensuring that agents will speak the same language and share a common, unambiguous semantics of the vocabulary, is called the ontology problem. The OAA provides a few tools (see more about agent development tools in the work by M artin et al. <ref type="bibr">(1996)</ref>) and services (automatic translations of solvables by the facilitator) to help minimize this issue; however, the OAA still must rely on vocabulary from either formally engineered ontologies for speci? c domains (for instance, see http ://www-ksl.stanford.edu/knowledge-sharing /ontologies/ html/) or on ontologies constructed during the incremental development of a body of agents for several applications.</p><p>Although OAA imposes no hard restrictions (other than the basic syntax) on the form of solvable declarations, two common usage conventions illustrate some of the utility associated with solvables.</p><p>of services are often tagged by a particular type. For instance, in d Classes the example above, the ''last -message'' and ''get -message'' solvables are specialized for e-mail, not by modifying the names of the services, but rather by the use of the email parameter, which serves during the execution of an ICL request to select (or not) a speci? c type of message.</p><p>are generally written using an imperative verb as the functor of </p><note type="other">usable by the function. The ICL expression generated by a natural language parser often makes use of this parameter list to store prepositional phrases and adjectives.</note><p>As an illustration of the above two points, ''Send mail to Bob about lunch'' will be translated into an ICL request send -message(email, 'Bob Jones', [ subject(lunch)] ), whereas ''Remind Bob about lunch'' would leave the transport unspeci? ed : (send -message(K IND, 'Bob Jones', [ subject(lunch)] )), enabling all available message transfer agents (e.g., fax, phone, mail, pager) to compete for the opportunity to carry out the request.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Requesting Services</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Overview</head><p>An agent requests services of the community by delegating tasks or goals to its facilitator. Each request contains calls to one or more agent solvables and optionally speci? es parameters containing advice to help the facilitator determine how to execute the task. It is important to note that calling a solvable does not require that the agent specify (or even know of) a particular agent or agents to handle the call. While it is possible to specify one or more agents using an address parameter (and there are situations in which this is desirable), in general, it is advantageous to leave this delegation to the facilitator. Programming in this style greatly reduces the hard-coded dependencies among components that one often ? nds in other distributed frameworks.</p><p>The OAA libraries provide an agent with a single, uni? ed point of entry for requesting services of other agents : the library procedure oaa -Solve. In the style of logic programming, oaa -Solve may be used both to retrieve data and to initiate actions. To put this another way, calling a data solvable looks the same as calling a procedure solvable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Compound Goals</head><p>One of the most powerful features of OAA is the ability of a client agent (or a user) to submit compound goals to a facilitator. A compound goal is composed using operators similar to those employed by P ROLOG, that is, the comma for conjunction, the semicolon for disjunction, and the arrow for conditional execution. Three of the several signi? cant extensions to PROLOG syntax and semantics are of particular interest here. First, a ''parallel disjunction'' operator indicates that the disjuncts are to be executed (by di erent agents) simultaneously. Second, it is possible to specify whether a given subgoal is to be executed breadth-? rst or depth-? rst.* Third, each</p><note type="other">subgoal of a compound goal can have an address and/ or a set of parameters attached to it. Thus each subgoal takes the form Address :Goal : :Parameters where both Address and Parameters are optional.</note><p>An address, if present, speci? es one or more agents to handle the given goal and may employ several di erent types of referring expression : unique names, symbolic names, and shorthand names. Every agent has a unique name, assigned by its facilitator, which relies upon network addressing schemes to ensure its global uniqueness. Agents also have self-selected symbolic names (for example, ''mail''), which are not guaranteed to be unique. When an address includes a symbolic name, the facilitator takes this to mean that all agents having that name should be called upon. Shorthand names include ''self'' and ''parent'' (which refers to the agent's facilitator). We emphasize that the address associated with a goal or subgoal is always optional. When an address is not present, it is the facilitator's job to supply an appropriate address, as explained in the section below, F acilitation.</p><p>The distributed execution of compound goals becomes particularly powerful when used in conjunction with natural language or speech-enabled interfaces, as the query itself may specify how functionality from distinct agents will be combined. As a simple example, the spoken utterance, ''F ax it to Bill Smith's manager'' can be translated into the following compound ICL request :</p><formula xml:id="formula_3">oaa -Solve((manager(` Bill Smith' , M), fax(it,M,[])),</formula><p>[strategy(action)])</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Re ning Service Requests</head><p>The parameters associated with a goal (or subgoal) can draw on useful features to re? ne the request's meaning. F or example, it is frequently important to be able to specify whether or not solutions are to be returned synchronously ; this is done using the reply parameter, which can take any of the values synchronous, asynchronous, or none. As another example, when the goal is a noncompound query of a data solvable, the cache parameter may be used to request local caching of the facts associated with that solvable. M any of the remaining parameters fall into two categories : advice and feedback.</p><p>Feedback parameters allow a service requester to receive information from the facilitator about how a goal was handled. This feedback can include such things as the identities of the agents involved in satisfying the goal and the amount of time expended in the satisfaction of the goal.</p><p>Advice parameters give constraints or guidance for the facilitator to use in completing and interpreting the goal. For example, the solution -limit parameter allows the requester to say how many solutions it is interested in ; the facilitator and/or service providers are free to use this information in optimizing their e orts. Similarly, time -limit is used to say how long the requester is willing to wait for solutions to its request, and in a multifacilitator system, level -limit may be used to say how remote the facilitators may be that are consulted in the search for solutions. The priority parameter is used to indicate that a request is more urgent than previous requests that have not yet been satis? ed. Other advice parameters are used to tell the facilitator whether parallel satisfaction of the parts of a goal is appropriate, how to combine and ? lter results arriving from multiple solver agents, and whether the requester itself may be considered a candidate solver of the subgoals of a request.</p><p>As mentioned above in the section Interagent Communication Language, advice parameters are intended to provide an extensible set of lowlevel orthogonal parameters capable of combining with the ICL goal language to fully express how information should ? ow among participants. M ultiple parameters can be grouped together and given a group name ; the resulting high-level advice parameters can be used to express concepts analogous to K QM L's performatives but also to de? ne classi? cations of problem types. F or instance, KQM L's ''ask -all'' and ''ask -one'' performatives would be represented as combinations of values given to the parameters reply, parallel -ok, and solution -limit. As an example of a higher-level problem type, the strategy ''math -problem'' might send the query to all appropriate math solvers in parallel, collect their responses, and signal a con? ict if di erent answers are returned. The strategy ''essay -question'' would send the request to all appropriate participants and signal a problem (i.e., cheating) if any of the returned answers are identical.</p><p>When a facilitator receives a compound goal, its job is to construct a goal satisfaction plan and oversee its satisfaction in the most appropriate, efficient manner that is consistent with the speci? ed advice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F acilitation</head><p>Facilitation plays a central role in OAA. At its core, our notion of facilitation is similar to that proposed by Genesereth <ref type="bibr" target="#b9">(Genesereth &amp; Singh, 1993)</ref> and others. In short, a facilitator maintains a knowledge base that records the capabilities of a collection of agents and uses that knowledge to assist requesters and providers of services in making contact. But our notion of facilitation is also considerably stronger in four respects.</p><p>First, it encompasses a very general notion of transparent delegation, which means that a requesting agent can generate a request, and a facilitator can manage the satisfaction of that request, without the requester needing to have any knowledge of the identities or locations of the satisfying agents. In some cases, such as when the request is a data query, the requesting agent may also be oblivious to the number of agents involved in satisfying a request. Transparent delegation is possible because agents' capabilities (solvables) are treated as an abstract description of a service, rather than as an entry point into a library or body of code.</p><p>Second, an OAA facilitator is distinguished by its handling of compound goals (introduced above). This involves three types of processing : delegation, that is, determination of who (which speci? c agents) will execute a compound goal and how (combination and routing of results from subgoals); optimization of the completed goal, including parallelization where appropriate; and interpretation of the optimized goal. The delegation step results in a goal that is unambiguous as to its meaning and as to the agents that will participate in satisfying it. Completing the addressing of a goal involves the selection of one or more agents to handle each of its subgoals (that is, each subgoal for which this selection has not been speci? ed by the requester). In doing this, the facilitator uses its knowledge of the capabilities of its client agents (and possibly of other facilitators, in a multifacilitator system). It may also use strategies or advice speci? ed by the requester, as explained below. The optimization step results in a goal whose interpretation will require as few exchanges as possible, between the facilitator and the satisfying agents, and can exploit parallel e orts of the satisfying agents, wherever this does not a ect the goal's meaning. The interpretation of a goal involves the coordination of requests to the satisfying agents and assembling their responses into a coherent whole for return to the requester.</p><p>The third respect in which OAA facilitation extends the basic concept of facilitation is that the facilitator can employ strategies and advice given by the requesting agent, thus resulting in a variety of interaction patterns that may be instantiated in the satisfaction of a request. Some of these strategies are mentioned in the previous section, and additional possibilities under consideration are mentioned in the section below, F uture Directions.</p><p>Finally, the OAA concept of facilitation has been generalized so as to handle the distribution of both data update requests and requests for installation of triggers, using some of the same strategies that are employed in the delegation of service requests. (Triggers and data maintenance mechanisms are discussed in the next two sections.)</p><p>It should be noted that the reliance on facilitation is not absolute ; that is, there is no hard requirement that requests and services be matched up by the facilitator or that interagent communications go through the facilitator. (Indeed, as mentioned elsewhere, there is support in the agent library for explicit addressing of requests, and planned support for peer-to-peer communications.) However, OAA has been designed so as to encourage developers to employ the paradigm of community and to minimize their development e ort in doing so, by taking advantage of the facilitator's provision to transparent delegation and handling of compound goals.</p><p>In summary, we stress that a facilitator is always viewed as a coordinator, not a controller, of cooperative task completion. The facilitator never initiates an activity but rather responds to requests to manage the satisfaction of some goal, the update of some data repository, or the installation of a trigger by the appropriate agent or agents. This approach makes it possible for all agents to take advantage of the facilitator's expertise in delegation and its up-to-date knowledge about the current membership of a dynamic community. In addition, in many situations, the facilitator's coordination services allow the developer to lessen the complexity of individual agents, resulting in a more manageable software development process and enabling the creation of lightweight agents.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M aintaining Data Repositories</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Overview</head><p>The agent library supports the creation, maintenance, and use of databases, in the form of data solvables. Creation of a data solvable requires only that it be declared, as explained in the section above, Speci? cation of Solvables. Querying a data solvable, as with access to any solvable, is done using oaa -Solve. Here we clarify the ways in which these solvables are maintained and used and mention some of the features associated with them.</p><p>A data solvable is conceptually the same as a relation in a relational database. The facts associated with each solvable are maintained by the agent library, which also handles incoming messages containing queries of data solvables. It is possible to re? ne the default behavior of the library in managing these facts, using parameters speci? ed with the solvable's declaration. For example, the parameter single -value is used to indicate that the solvable should only contain a single fact at any given point in time. The parameter unique -values indicates that no duplicate values should be stored.</p><p>Other parameters can allow data solvables to make use of the concepts of ownership and persistence. Because data solvables are often used to implement shared repositories, it can be useful to maintain a record of which agent created each fact of a solvable ; this agent is considered to be the fact's owner. In many applications, it is useful to have an agent's facts removed when that agent goes o -line (that is, the agent is no longer participating in the agent community, whether by deliberate termination or by malfunction). When a data solvable is declared to be nonpersistent, its facts are automatically maintained in this way, whereas a persistent data solvable retains its facts until they are explicitly removed.</p><p>The agent library provides procedures by which agents can update (add, remove, and replace) facts belonging to data solvables, either locally or on other agents, given that they have the required permissions. These procedures may be re? ned using many of the same parameters that apply to service requests. For example, the address parameter is used to specify one or more particular agents to which the update request applies. In its absence, just as with service requests, the update request goes to all agents providing the relevant data solvable. This default behavior can be used to maintain coordinated ''mirror'' copies of a data set within multiple agents and can be useful in support of distributed, collaborative activities.</p><p>Similarly, the feedback parameters, described in connection with oaa -Solve, are also available for use with data maintenance requests.</p><p>The ability to provide data solvables is not limited to client agents ; data solvables can also be maintained by a facilitator, at the request of a client of the facilitator, and their maintenance and use shared by all the facilitator's clients. This can be a useful strategy with a relatively stable collection of agents, where the facilitator's workload is predictable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Using a Blackboard Style of Communication</head><p>When a data solvable is publicly readable and writable, it may be thought of as a global data repository, which can be used cooperatively by a group of agents. In combination with the use of triggers, this allows the agents to organize their e orts around a ''blackboard'' style of communication.</p><p>As an example, the ''DCG-NL'' agent (one of several existing natural language processing agents), which provides natural language processing services for a variety of its peer agents, expects those other agents to record, on the facilitator, the vocabulary to which they are prepared to respond, with an indication of each word's part of speech and of the logical form (ICL subgoal) that should result from the use of that word. To make this possible, when it comes on-line, the NL agent installs a data solvable for each basic part of speech on its facilitator. For instance, one such solvable would be</p><formula xml:id="formula_4">solvable(noun(Meaning, Syntax), [], [])</formula><p>(Note that the empty lists for the solvable's permissions and parameters are acceptable here, since the default permissions and parameters provide appropriate functionality.)</p><p>In the Office Assistant system, several agents make use of these services. For instance, the database agent uses the following call, to library procedure oaa -AddData, to post the noun ''boss'' and to indicate that the ''meaning'' of boss is the concept ''manager'': oaa -AddData(noun(manager, atom(boss)), [address(parent)])</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AUTON OM OUS M ON ITORIN G WITH TRIGGERS</head><p>OAA triggers provide a general mechanism for requesting that some action be taken when some set of conditions is met. Each agent can install triggers either locally, for itself, or remotely, on its facilitator or peer agents. There are four types of triggers : communication, data, task, and time. In addition to a type, each trigger speci? es a condition and an action, both expressed in ICL. The condition indicates under what circumstances the trigger should ? re, and the action indicates what should happen when it ? res. In addition, each trigger can be set to ? re either an unlimited number of times or a speci? ed number of times, which can be any positive integer.</p><p>Triggers are used in a wide variety of ways within OAA systems, for example, for monitoring external sensors in the execution environment, tracking the progress of complex tasks, or coordinating communications between agents that are essential for the synchronization of related tasks. The installation of a trigger within an agent can be thought of as a representation of that agent's commitment to carry out the speci? ed action, whenever the speci? ed condition holds true.</p><p>The four types of triggers can be characterized informally as follows :</p><p>triggers allow any incoming or outgoing event (message) d Communication to be monitored. For instance, a simple communication trigger may say something like, ''Whenever a solution to a goal is returned from the facilitator, send the result to the presentation manager to be displayed to the user.'' triggers monitor the state of a data repository (which can be maind Data tained on a facilitator or a client agent). Data triggers' conditions may be tested upon the addition, removal, or replacement of a fact belonging to a data solvable. An example data trigger is, When 15 users are simultaneously logged onto a machine, send an alert message to the system administrator.</p><p>triggers contain arbitrary conditions that are tested after the prod T ask cessing of each incoming event and whenever a time-out occurs in the event polling. These conditions may specify any goal executable by the local ICL interpreter and most often are used to test when some solvable becomes satis? able. Task triggers are useful in checking for task-speci? c internal conditions. Although in many cases such conditions are captured by solvables, in other cases they may not be. For example, a mail agent might watch for new incoming mail, or an airline database agent may monitor which ? ights will arrive later than scheduled. An example task trigger is, When mail arrives for me about security, notify me immediately.</p><p>triggers monitor time conditions. F or instance, an alarm trigger can d T ime be set to ? re at a single ? xed point in time (e.g., ''On December 23rd at 3pm'') or on a recurring basis (e.g., ''Every three minutes from now until noon'').</p><p>Triggers are implemented as data solvables, declared implicitly for every agent. When requesting that a trigger be installed, an agent may use many of the same parameters that apply to service and data maintenance requests.</p><p>One important feature of OAA triggers is that, in contrast with most programming methodologies, the agent on which the trigger is installed only has to know how to evaluate the conditional part of the trigger, not the consequence? when the trigger ? res, the action is delegated to the facilitator for execution. Whereas many commercial mail programs allow rules of the form, ''When mail arrives about XXX, [ forward it, delete it, archive it] ,'' the possible actions are hard-coded, and the user must select from a ? xed set. In OAA the consequence may be any compound goal executable by the dynamic community of agents. Since new agents de? ne both functionality and vocabulary, when an unanticipated agent (for example, a fax agent) joins the community, no modi? cations to the existing code are required for a user to make use of it? ''When mail arrives, fax it to Bill Smith.''</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AGENT LIBRARY</head><p>OAA's agent library, which provides the necessary infrastructure for constructing an agent-based system, is available in several programming languages, including P ROLOG, C, JAVA, LISP , VISUAL BASIC, and C1 1 , DELPHI. As mentioned earlier, two goals of the library's design have been to minimize the e ort required to construct a new system and to maximize the ease with which legacy systems can be agenti? ed.</p><p>The library's several families of procedures provide all the functionalities mentioned in this paper as well as many that are omitted for lack of space. For example, declarations of an agent's solvables and their registration with a facilitator are managed using procedures such as oaa -Declare, oaa -Undeclare, and oaa -Redeclare. Updates to data solvables can be accomplished with a family of procedures, including oaa -AddData, oaa -RemoveData, and oaa -ReplaceData. Similarly, triggers are maintained using procedures such as oaa -AddTrigger, oaa -RemoveT rigger, and oaa -ReplaceT rigger.</p><p>The essential elements of protocol (that is, the details of the messages that encapsulate a service request and its response) are provided by the library and made transparent insofar as possible, so that the application code can be simpler. This enables the developer to focus on the desired functionality rather than on the details of message construction and communication. For example, to request a service of another agent, an agent calls the library procedure oaa -Solve. This call results in a message to a facilitator, which will exchange messages with one or more service providers and then send a message containing the desired results to the requesting agent. These results are returned via one of the arguments of oaa -Solve. N one of the messages involved in this scenario is explicitly constructed by the agent developer. (Note that this is a description of the synchronous use of oaa -Solve.)</p><p>The agent library provides both intraagent and interagent infrastructure, that is, mechanisms supporting the internal structure of individual agents, on the one hand, and mechanisms of cooperative interoperation between agents, on the other. It is worth noting that most of the infrastructure cuts across this boundary ; that is, many of the same mechanisms support both agent internals and agent interactions in an integrated fashion. For example, services provided by an agent can be accessed by that agent through the same procedure (oaa -Solve) that it would employ to request a service of another agent (the only di erence being in the address parameter accompanying the request). This, in turn, helps the developer to reuse code and avoid redundant entry points into the same functionality.</p><p>Both of the characteristics described above (transparent construction of messages and integration of intraagent with interagent mechanisms) apply to most other library functionality as well, including data management and temporal control mechanisms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>OAA APPLICATION S</head><p>The OAA has been used to implement more than ? fteen applications integrating such diverse technologies as image processing, speech recognition, multiuser collaboration, text extraction, planning, and virtual reality. <ref type="table" target="#tab_2">Table 1</ref> is a partial list of OAA-based applications from which we will take a few examples to illustrate qualities important to the framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Uni ed M essaging</head><p>The Uni? ed M essaging application extends the Automated Office pre- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Application Description</head><p>Automated Of? ce M obile interfaces (PDA with telephone) to integrated community of commercial of? ce applications (calendar, database, e-mail) and AI technologies (speech recognition, speaker identi? cation, text to speech, natural language interpretation and generation) <ref type="bibr" target="#b3">(Cohen et al., 1994</ref>) Uni? ed messaging Adaptable, ubiquitous access to e-mail, fax, voice, and Web messages and services M ultimodal M ap P en/voice interface to distributed Web data <ref type="bibr" target="#b0">(Cheyer &amp; Julia, 1995</ref>) InfoWiz Animated voice interactive interface to the Web ATIS-Web</p><p>Try out a live demo of speech recognition over the Web ! Available at http :// www.speech.sri.com/ demos/atis.html CommandTalk Spoken-language interface for controlling simulated forces (M oore et al., 1996) Spoken dialog Real-time system for summarizing human-human summarization spontaneous spoken dialogs (Japanese) Language tutoring Speech recognition for foreign language learning, incorporating user modeling for adaptive lessons Disaster response Collaborative, wireless map-based interface for emergency response teams M VIEWS Integrating speech, pen, natural language, image, processing, and other technologies for the video analyst . OAA InfoBroker M ediated facilitation of heterogeneous structured and semistructured (Web) data sources (M artin et al., 1997) OAA Rental Agent M onitors the Web and noti? es user when housing classi? eds meet user speci? cations Agent development Guides the agent developer through the steps required to tools create new agents <ref type="bibr">(M artin et al., 1996</ref>) M ultirobot control</p><p>Team of robots works together on assigned tasks (? rst place, AAAI Of? ce Navigation Event) ( <ref type="bibr" target="#b10">Guzzoni et al., 1997</ref>) Surgical telepresence F orce feedback training simulator for endoscopic surgery ; all physical and virtual entities modeled as OAA agents sented in the section above, Overview of OAA, with an emphasis on ubiquitous access and dynamic presentation of the information and services supported by the agent community. The agents used in this application are depicted in <ref type="figure" target="#fig_5">Figure 4</ref>. A real dialog taken from the current system can provide insight into how systems are built using OAA. In this scenario the user, with only a telephone as an interface, is planning a trip to Boston, where he will soon give a presentation. Capitalized sentences are phrases spoken by the user into the telephone and processed by a phone agent. Responses, unless otherwise indicated, are spoken by the system using text-to-speech generation. Every user interface agent, including the telephone agent, should know the identity of its user. This information is used in resolving anaphoric references such as ''me'' and ''I'' and allows multiple user interfaces operated by the same user to work together. If the user is operating both a graphical user interface and a telephone, as described in conjunction with the Automated Office application, the result of this spoken request is to display a calender window containing the current schedule. In this case, with no graphical display available, the GEN -N L agent is tasked to produce a spoken response that can be played over the phone. GEN -N L shares the same dynamic vocabulary and phrasal rules as the natural language parser DCG -N L and contains strategies for producing responses to queries using either simple or list-based multimedia utterances.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">FIND FRIDAY' S WEATHER IN BOSTON.</head><p>The weather in Boston for Friday is as follows : Sunny in the morning. Partly cloudy in the afternoon with a 20 percent chance of thunderstorms late. Highs in the mid 70s.</p><p>In addition to data accessible from legacy applications, content may be retrieved by Web-reading agents provide OAA wrappers around useful Web sites. M ail messages are no longer just simple text documents but often consist of multiple subparts containing audio ? les, pictures, Web pages, attachments, and so forth. When a user asks to play a complex e-mail message over the telephone, many di erent agents may be implicated in the translation process, which would be quite di erent given the request ''print it.'' The challenge is to develop a system that will enable agents to cooperate in an extensible, ? exible manner that alleviates explicit coding of agent interactions for every possible input/output combination.</p><p>In an OAA implementation, each agent concentrates only on what it can do and on what it knows and leaves other work to be delegated to the agent community. For instance, a printer agent, de? ning the solvable print(Object, Parameters), can be de? ned by the following pseudocode, which basically says, ''If someone can get me a document, in either POSTSCRIPT or text form, I can print it.''</p><formula xml:id="formula_5">print(Object, Parameters){ ' If Object is reference ttt' ' , find an appropriate document if (Object=`Object=`` ref(it)' ' ) oaa -Solve(resolve -reference(the, document, Params, Object), []) ;</formula><p>' Given a reference to some document, ask for the</p><formula xml:id="formula_6">document in POSTSCRIPT if (Object=`Object=`` id(Pointer)' ' ) oaa -Solve(resolve -id -as(id(Pointer), postscript, [], Object), [])</formula><p>; ' If Object is of type text or POSTSCRIPT, we can print it. if ((Object is of type Text) or (Object is of type Postscript)) do -print(Object) ; } In our example, since an e-mail message is the salient document, the mail agent will receive a request to produce the message as POSTSCRIPT. Whereas the mail agent may know how to save a text message as POST-SCRIPT, it will not know what to do with a Web page or voice mail message. For these parts of the message, it will simply send oaa -Solve requests to see if another agent knows how to accomplish the task.</p><p>Until now, the user has been using only a telephone as user interface. Now, he moves to his desktop, starts a Web browser, and accesses the URL referenced by the mail message.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.9">RECORD MESSAGE</head><p>Recording voice message. Start speaking now.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.10">THIS IS THE UPDATED WEB PAGE CONTAINING THE PRESENTATION SCHEDULE.</head><p>Message one recorded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.11">IF THIS WEB PAGE CHANGES, GET IT TO ME WITH NOTE ONE.</head><p>Trigger added as requested.</p><p>In this example, a local agent that interfaces with the Web browser can return the current page as a solution to the request ''oaa -Solve(resolve -reference(this, web-page, [ ] , Ref),[ ] )'' sent by the N L agent. A trigger is installed on a Web agent to monitor changes to the page, and when the page is updated, the notify agent can ? nd the user and transmit the Web page and voice mail message using the most appropriate media transfer mechanism. This example based on the Uni? ed M essaging application is intended to show how OAA concepts can be used to produce a simple yet extensible solution to a multiagent problem that would be difficult to implement using a more rigid framework. The application supports adaptable presentation for queries across dynamically changing, complex information ; shared context and reference resolution among applications ; and ? exible translation of multimedia data. In the next section, we will present an application that highlights the use of parallel competition and cooperation among agents during multimodal fusion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M ultimodal M ap</head><p>The goal of the M ultimodal M ap application is to explore natural ways of communicating with a community of agents. Inspired by the way a professor would instruct his students at a blackboard, through combinations of drawing, writing, speaking, gesturing, circling, underlining, and so forth, the M ultimodal M ap provides an interactive interface on which the user may draw, write, or speak. In a travel planning domain (F igure 5), available information includes hotel, restaurant, and tourist-site data retrieved by distributed software agents from commercial Internet sites. The types of user interactions and multimodal issues handled by the application can be illustrated by a brief scenario from  featuring working examples taken from the current system.</p><p>Sara is planning a business trip to San Francisco but would like to schedule some activities for the weekend while she is there. She turns on her laptop  Price appears for previous hotel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PC, executes a map application, and selects San</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.9">[Speaking and drawing an arrow] Scroll down. Display adjusted. 2.10 [Speaking and drawing an arrow toward a hotel]</head><p>What is the distance from this hotel to Fisherman' s Wharf ? Distance displayed. 2.11 [Pointing to another place and speaking] And the distance to here ? Distance displayed. Sara decides she could use some human advice. She picks up the phone, calls Bob, her travel agent, and writes Start collaboration to synchronize his display with hers. At this point, both are presented with identical maps, and the input and actions of one will be remotely seen by the other.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">[Sara speaks and circles two hotels] Bob, I' m trying to choose between these two hotels. Any opinions ? 3.2 [Bob draws an arrow, speaks, and points]</head><p>Well, this area is really nice to visit. You can walk there from this hotel. Map scrolls to indicated area. Hotel selected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">[Sara speaks] Do you think I should visit Alcatraz ? 3.4 [Bob speaks] Map, show video of Alcatraz.</head><p>Video appears.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">[Bob speaks] Yes, Alcatraz is a lot of fun.</head><p>For this system the main research focus is on how to generate the most appropriate interpretation for the incoming streams of multimodal input. Besides providing a user interface to a dynamic set of distributed agents, the application is built using an agent framework, with the OAA helping coordinate competition and cooperation among information sources, which work in parallel to resolve the ambiguities arising at every level of the interpretation process : processing of the data stream : P en input may be interpreted as d Low-level a gesture (e.g., 2.5 : crossout) by one algorithm or as handwriting by a separate recognition process (e.g., 2.3 : ''info ?''). M ultiple hypotheses may be returned by a modality recognition component.</p><p>resolution </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>?</head><p>Context by object type: For an utterance such as ''show photo of the hotel,'' the natural language component can return a list of the last hotels talked about.</p><p>? Deictic : In combination with a spoken utterance like ''show photo of this hotel,'' pointing, circling, or arrow gestures might indicate the desired object (e.g., 2.7). Deictic references may occur before, during, or after an accompanying verbal command.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>?</head><p>Visual context : Given the request ''display photo of the hotel,'' the user interface agent might determine that only one hotel is currently visible on the map, and therefore this might be the desired reference object. Cross-modality one modality may reinforce or disambiguate the interpretation of another. F or instance, the interpretation of an arrow gesture may vary when accompanied by di erent verbal commands (e.g., ''scroll left'' versus ''show info about this hotel''). In the latter example the system must take into account how accurately and unambiguously an arrow selects a single hotel.</p><p>With the addition of collaboration technology, humans and d Addressee : automated agents all share the same workspace. A pen doodle or a spoken utterance may be meant for either another human, the system (3.1), or both (3.2).</p><p>The implementation of the M ultimodal M ap application exploits several features of the OAA: resolution and task delegation are handled in a distributed d Reference fashion by the parallel parameters of oaa -Solve, with meta-agents encoding rules to help the facilitator make context-or user-speci? c decisions about priorities among knowledge sources. multiuser collaboration is handled through OAA's built-in data d Basic management services. The map user interface publishes data solvables for elements such as icons, screen position, and viewers and de? nes these elements to have the attribute ''shareable.'' F or every update to this public data, the changes are automatically replicated to all members of the collaborative session, with associated callbacks producing the visible e ect of the data change (e.g., adding or removing an icon). for recording and playback of a session is easily implement- F unctionality ed by adding agents as members of the collaborative community. These agents either record the data changes to disk or read a log? le and replicate the changes in the shared environment. domain-speci? c code for interpreting travel planning dialog is cleanly d</p><p>The separated from the speech, natural language, pen recognition, database, and map user interface agents. These components were reused without modi? cation to add multimodal map capabilities to other applications for activities such as crisis management, multirobot control, and the M VIEWS tools for the video analyst.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RELATED WORK</head><p>Agent-based systems have shown much promise for ? exible, faulttolerant, distributed problem solving. M uch of the foundational work on agent technology has focused on interagent communication protocols ( <ref type="bibr" target="#b4">Finin et al., 1997</ref>), patterns of conversation for agent interactions <ref type="bibr">(FIPA, 1997)</ref>, and basic facilitation capabilities, including agent name servers and other types of registry services (e.g., brokers, matchmakers) ( <ref type="bibr" target="#b19">Sycara et al., 1996)</ref>.</p><p>Because there is insufficient space here to cover the gamut of work on agent architectures, we restrict ourselves to mentioning several projects that have helped to evolve some notion of facilitation. Genesereth has emphasized the role of a facilitator <ref type="bibr" target="#b9">(Genesereth &amp; Singh, 1993 ;</ref><ref type="bibr" target="#b8">Genesereth &amp; Katchpel, 1994)</ref> and describes <ref type="bibr" target="#b9">(Genesereth &amp; Singh, 1993)</ref> a facilitator based on logical reasoning. This facilitator shares our emphasis on content-based routing and the synthesis of complex multistep delegation plans but does not go as far as OAA in allowing the service requester to in? uence the strategies used by the facilitator. Similarly, the InfoSleuth system <ref type="bibr" target="#b16">(Nodine &amp; Unruh, 1997</ref>) employs matchmaking agents having the ability to reason deductively about whether expressions of requirements (by requesters) match with the advertised capabilities of service providers. KQM L <ref type="bibr" target="#b4">Finin et al., 1997</ref>) provides ''capability-de? nition performatives,'' such as advertise, and ''facilitation performatives,'' such as broker -one and broker -all. While these performatives may be suitable for structuring the basic interactions between the players in a facilitated system, it should be noted that they provide only a communication protocol. That is, the speci? c strategies employed by a facilitator, and the means of advising facilitator in selecting a strategy, are beyond the scope of KQM L speci? -cations. Sycara et al. delineate the concepts of matchmaking, brokering, and facilitation in a useful way and explore the trade-o s inherent in the use of these approaches. Overall, they ? nd that a brokered or facilitated system can exhibit dramatically better performance than one based on matchmaking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F UTURE DIRECTION S</head><p>M uch work remains to be done, both at the implementation and conceptual levels. Areas for further investigation include scalability, robustness (fault tolerance), improved development and runtime tools, and improved facilitation strategies and services.</p><p>The use of facilitators o ers both advantages and weaknesses with respect to scalability and fault tolerance. On the plus side, the grouping of a facilitator with a collection of client agents provides a natural building block from which to construct larger systems. On the minus side, there is the potential for a facilitator to become a communication bottleneck or a critical point of failure. In tasks requiring a sequence of exchanges between two agents, it is possible for a facilitator to assist them in ? nding one another and establishing communication but then to step out of the way while they communicate over a direct, dedicated channel. This is a relatively straightforward extension to our approach, which we plan to incorporate. F or more complex task con? gurations, we see three general areas to explore in addressing these issues. F irst, a variety of multifacilitator topologies can be exploited in constructing large systems. It would be useful to investigate which of these exhibits the most desirable properties with respect to both scalability and fault tolerance. Second, it is possible to modularize the facilitator's key functionalities. F or example, goal planning (delegation and optimization) can readily be separated from goal execution. Given this, one can envision a con? guration in which the execution task is distributed to other agents, thus freeing up the facilitator. Third, we would like to incorporate mechanisms for basic transaction management, periodically saving the state of agents (both facilitator and client), and rolling back to the latest saved state in the event of the failure of an agent.</p><p>With respect to agent development tools, we plan on updating our initial work in this area <ref type="bibr">(described at PAAM 96 by M artin et al. (1996)</ref>) to a more group-oriented and Web-centric design. Improvements to the linguistic tools and a graphical monitoring agent would also be desirable.</p><p>While much work has been done by agent researchers to demonstrate increased autonomy of individual agents (particularly in the category of information ? ltering and personal assistants), smarter and more autonomous facilitators (or other means of coordinating multiple agents) are likely to be more critical to the evolution of multiagent systems. Our experience to date has shown value in the handling of compound goals, with advice parameters, by facilitators. However, the advice is still relatively simple, and the discretion exercised by the facilitator relatively limited. Thus we are interested in exploring the use of more sophisticated strategies by the facilitator, guided by a higher level of advice. It may be possible to draw upon existing work in the (arti? cial intelligence) ? eld of planning and the (database) ? eld of query planning. Facilitation is also likely to bene? t from richer representations of agents' capabilities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SUM M ARY</head><p>The Open Agent Architecture provides a framework for the construction of distributed software systems, which facilitates the use of cooperative task completion by ? exible, dynamic con? gurations of autonomous agents. We have presented the rationale underlying its design, compared its features to those of other distributed frameworks, and summarized the applications built to date using it. In addition, we have described the major components of OAA infrastructure and the mechanisms used in assembling an agentbased system. These mechanisms include a general approach to achieving cooperation between agents, organized around the declaration of capabilities by service-providing agents, the construction of goals by users and service-requesting agents, and the role of facilitators in coordinating the satisfaction of these goals, subject to advice and constraints that may accompany them ; facilities for creating and maintaining shared repositories of data ; and the use of triggers to instantiate commitments within and between agents.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>REF EREN CES</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>d</head><label></label><figDesc>Inheritance and data without requiring source code to the original library. allows one body of code to work on an arbitrary number of d Polymorphism data types.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>d</head><label></label><figDesc>Support cessing resources) between users and agents.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>FIGURE 2 .</head><label>2</label><figDesc>FIGURE 2. Automated office agents.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>FIGURE 3 .</head><label>3</label><figDesc>FIGURE 3. User interface for automated office application.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>d</head><label></label><figDesc>Actions the solvable, the direct object (or item class) as the ? rst argument of the predicate, required arguments following, and then an extensible parameter list as the last argument. The parameter list can hold optional information</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>FIGURE 4 .</head><label>4</label><figDesc>FIGURE 4. Uni? ed messaging agents.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>FIGURE 5 .</head><label>5</label><figDesc>FIGURE 5. M ultimodal map application.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>?</head><label></label><figDesc>Database queries : Information from a database agent can be combined with results from other resolution strategies. Examples are, ''show me a photo of the hotel in M enlo Park'' and 2.2. ? Discourse analysis : Discourse can provide a source of information for phrases such as, ''N o, the other one'' (or 2.8). This list is by no means exhaustive. Examples of other resolution methods include spatial reasoning (''the hotel between Fisherman's Wharf and Lombard Street'') and user preferences (''near my favorite restaurant''). in? uences : When multiple modalities are used together, d</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>d Encourage ponents. The concept of agent orientation, like</head><label></label><figDesc></figDesc><table>that of object orientation, 
provides a natural conceptual framework for reuse, so long as mecha-
nisms for encapsulation and interaction are structured appropriately. 
lightweight, mobile platforms. Such platforms should be able to 

d 

Support 
serve as hosts for agents, without requiring the installation of a massive 
environment. It should also be possible to construct individual agents that 
are relatively small and modest in their processing requirements. 
platform and language barriers. Creation of new agents, as well 

d 

M inimize 
as wrapping of existing applications, should not require the adoption of a 
new language or environment. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>TABLE 1 Partial List of Applications Written Using OAA</head><label>1</label><figDesc></figDesc><table></table></figure>

			<note place="foot" n="1">. As new agents connect to the facilitator, registering capability speci? -cations and natural language vocabulary, what the user can say and do dynamically changes.</note>

			<note place="foot">* This capability is under development.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">M ultimodal maps : An agent-based approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Cheyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Julia</surname></persName>
		</author>
		<ptr target="http://www.ai.sri.com" />
	</analytic>
	<monogr>
		<title level="m">Proc. of the International Conference on Cooperative Multimodal Communication (CM C/95)</title>
		<meeting>of the International Conference on Cooperative Multimodal Communication (CM C/95)<address><addrLine>Eindhoven, The Netherlands, M ay</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">M views : M ultimodal tools for the video analyst</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Cheyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Julia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1998 International Conference on Intelligent User Int erfaces (IUI98)</title>
		<meeting>the 1998 International Conference on Intelligent User Int erfaces (IUI98)<address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A uni? ed framework for constructing multimodal applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Cheyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Julia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1998 Conference on Cooperative Multimodal Communication (CM C98)</title>
		<meeting>the 1998 Conference on Cooperative Multimodal Communication (CM C98)<address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An open agent architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">R</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Cheyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">C</forename><surname>Baeg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the AAAI Spring Symposium Series on Software Agents</title>
		<editor>O. Etzioni, 1? 8. M enlo Park</editor>
		<meeting>of the AAAI Spring Symposium Series on Software Agents</meeting>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">KQM L as an agent communication language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Finin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Labrou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<editor>Software agents, ed. J. Bradshaw. Cambridge</editor>
		<imprint>
			<date type="published" when="1997" />
			<publisher>M IT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Foundation for intelligent physical agents (FIPA) 1997 speci? cation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fip</forename><forename type="middle">A</forename></persName>
		</author>
		<ptr target="http://drogo.cselt.stet.it/?pa/spec/?pa97.htm" />
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gelernter</surname></persName>
		</author>
		<title level="m">Mirror worlds. N ew York</title>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Knowledge interchange format version 3.0 reference manual</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">R</forename><surname>Genesereth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Fikes</surname></persName>
		</author>
		<idno>Logic-92-1</idno>
		<ptr target="http://logic.stanford.edu/kif/kif.html" />
		<imprint>
			<date type="published" when="1992" />
			<pubPlace>Stanford, CA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Stanford University</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Software agents</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">R</forename><surname>Genesereth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Katchpel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="48" to="53" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">A knowledge sharing approach to software interoperation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">R</forename><surname>Genesereth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">P</forename><surname>Singh</surname></persName>
		</author>
		<idno>Logic-93-1</idno>
		<imprint>
			<date type="published" when="1993" />
			<pubPlace>Stanford, CA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Stanford University</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">M any robots make short work : Report of the SRI international moble robot team</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Guzzoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Cheyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Julia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Konolige</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AI Magazine</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="64" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">A proposal for a new KQM L speci? cation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Labrou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Finin</surname></persName>
		</author>
		<idno>CS-97-03</idno>
		<ptr target="http://www.cs.umbc.edu/kqml/D.L.Martinetal" />
		<imprint>
			<date type="published" when="1997-02" />
			<pubPlace>Baltimore, M aryland</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Computer Science and Electrical Engineering Department, University of M aryland Baltimore County</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Agent development tools for the open agent architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Cheyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G.-L</forename><surname>Lee</surname></persName>
		</author>
		<idno>387? 404</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Conference on the Practical Application of Intelligent Agents and Multi-Agent T echnology</title>
		<meeting>the First International Conference on the Practical Application of Intelligent Agents and Multi-Agent T echnology<address><addrLine>Blackpool, Lancashire, UK</addrLine></address></meeting>
		<imprint>
			<publisher>The Practical Application Company Ltd</publisher>
			<date type="published" when="1996-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Information brokering in an agent architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Oohama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Cheyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second International Conference on the Practical Application of Intelligent Agents and Multi-Agent T echnology</title>
		<meeting>the Second International Conference on the Practical Application of Intelligent Agents and Multi-Agent T echnology<address><addrLine>Blackpool, Lancashire, UK</addrLine></address></meeting>
		<imprint>
			<publisher>The Practical Application Company Ltd</publisher>
			<date type="published" when="1997-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Commandtalk : A spoken-language interface for battle? eld simulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">.</forename><forename type="middle">;</forename><surname>Dcom M Oore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dowding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Bratt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Gawron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Gorfu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">B</forename><surname>Cheyer ; D</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Cheyer</surname></persName>
		</author>
		<ptr target="http://www.ai.sri.com" />
	</analytic>
	<monogr>
		<title level="m">Proc. of International W orkshop on Human Interface T echnology 95 (IW HIT &apos;95)</title>
		<meeting>of International W orkshop on Human Interface T echnology 95 (IW HIT &apos;95)<address><addrLine>Fukushima, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="volume">10</biblScope>
		</imprint>
		<respStmt>
			<orgName>12? 13 October. University of Aizu</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical report</note>
	<note>Aizu-Wakamatsu</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The open agent architecture and its multimodal user interface</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">B</forename><surname>M Oran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Cheyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">E</forename><surname>Julia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1997 International Conference on Intelligent User Interfaces (IUI97)</title>
		<meeting>the 1997 International Conference on Intelligent User Interfaces (IUI97)<address><addrLine>Orlando, F L, 6? 9</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">F acilitating open communication in agent systems : The InfoSleuth infrastructure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Nodine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Unruh</surname></persName>
		</author>
		<idno>M CC-INSL-056-97</idno>
	</analytic>
	<monogr>
		<title level="j">M icroelectronics and Computer Technology Corporation</title>
		<imprint>
			<date type="published" when="1997-04" />
		</imprint>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">The complete CORBA/IIOP 2.1 speci? cation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Object</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Group</surname></persName>
		</author>
		<ptr target="http://www.omg.org/corba/corbiiop.htm" />
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">BDI agents from theory to practice</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>George</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">April</forename><surname>Aaai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">G</forename><surname>Schwartz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Technical Note</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<date type="published" when="1995" />
			<publisher>Kluwer Academic</publisher>
		</imprint>
	</monogr>
	<note>Cooperating heterogeneous systems</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">M atchmaking and brokering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sycara</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Decker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Williamson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Second International Conference on Multi-Agent Systems (ICMAS-96)</title>
		<meeting>of the Second International Conference on Multi-Agent Systems (ICMAS-96)</meeting>
		<imprint>
			<date type="published" when="1996-12" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
