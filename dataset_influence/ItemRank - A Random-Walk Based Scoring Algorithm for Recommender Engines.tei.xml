<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 D:\grobid-master\grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.1-SNAPSHOT" ident="GROBID" when="2018-07-16T23:56+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">ItemRank: A Random-Walk Based Scoring Algorithm for Recommender Engines</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Gori</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Ingegneria dell&apos;Informazione</orgName>
								<orgName type="institution">University of Siena Via Roma</orgName>
								<address>
									<postCode>56</postCode>
									<settlement>Siena</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Augusto</forename><surname>Pucci</surname></persName>
							<email>augusto@dii.unisi.it</email>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Ingegneria dell&apos;Informazione</orgName>
								<orgName type="institution">University of Siena Via Roma</orgName>
								<address>
									<postCode>56</postCode>
									<settlement>Siena</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">ItemRank: A Random-Walk Based Scoring Algorithm for Recommender Engines</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Recommender systems are an emerging technology that helps consumers to find interesting products. A recommender system makes personalized product suggestions by extracting knowledge from the previous users interactions. In this paper, we present &quot;ItemRank&quot;, a random-walk based scoring algorithm , which can be used to rank products according to expected user preferences, in order to recommend top-rank items to potentially interested users. We tested our algorithm on a standard database, the MovieLens data set, which contains data collected from a popular recommender system on movies, that has been widely exploited as a benchmark for evaluating recently proposed approaches to recommender system (e.g. [Fouss et al., 2005; Sarwar et al., 2002]). We compared ItemRank with other state-of-the-art ranking techniques (in particular the algorithms described in [Fouss et al., 2005]). Our experiments show that ItemRank performs better than the other algorithms we compared to and, at the same time, it is less complex than other proposed algorithms with respect to memory usage and computational cost too.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A recommender system makes personalized product suggestions by extracting knowledge from the previous user interactions with the system. Such services are particularly useful in the modern electronic marketplace which offers an unprecedented range of products. In fact a recommender system represents an added value both for consumers, who can easily find products they really like, and for sellers, who can focus their offers and advertising efforts. Several recommender systems have been developed that cope with different products, e.g. MovieLens for movies (see <ref type="bibr" target="#b2">[Sarwar et al., 2001]</ref>), GroupLens for usenet news <ref type="bibr" target="#b2">[Miller et al., 2002]</ref>, Ringo for music <ref type="bibr" target="#b2">[Shardanand and Maes, 1995]</ref>, Jester for jokes <ref type="bibr">[Gold- berg et al., 2001</ref>] and many other (see e.g. <ref type="bibr" target="#b2">[Schafer et al., 2001</ref>] for a review). A recommender system constructs a user profile on the basis of explicit or implicit interactions of the user with the system. The profile is used to find products to recommend to the user. In the simplest approach, the profile is constructed using only features that are related to the user under evaluation and to the products he/she has already considered. In those cases, the profile consists of a parametric model that is adapted according to the customer's behavior. Key issues of collaborative filtering approach are scalability and quality of the results. In fact, real life largescale E-commerce applications must efficiently cope with hundreds of thousands of users. Moreover, the accuracy of the recommendation is crucial in order to offer a service that is appreciated and used by customers. In this paper, we present "ItemRank", a random-walk based scoring algorithm, which can be used to rank products according to expected user preferences, in order to recommend top-rank items to potentially interested users. We tested our algorithm on a popular database, the MovieLens dataset 1 by the GroupLens Research group at University of Minnesota and we compared ItemRank with other state-of-the-art ranking techniques (in particular the algorithms described in <ref type="bibr" target="#b0">[Fouss et al., 2005]</ref>). This database contains data collected from a popular recommender system on movies that has been widely exploited as a benchmark for evaluating recently proposed approaches to recommender system (e.g. <ref type="bibr" target="#b0">[Fouss et al., 2005;</ref><ref type="bibr" target="#b2">Sarwar et al., 2002]</ref>). The schema of such archive resembles the structure of the data of many other collaborative filtering applications. Our experiments show that ItemRank performs better than the other algorithms we compared to and, at the same time, it is less complex than other proposed algorithms with respect to memory usage and computational cost too. The paper is organized as follows. In the next subsection (1.1) we review the related literature with a special focus on other graph based similarity measure and scoring algorithms applied to recommender systems. Section 2 describes the MovieLens data set (in subsection 2.1) and illustrates the data model we adopted (in subsection 2.2). Section 3 discusses ItemRank algorithm in details and we address ItemRank algorithm complexity issues in subsection 3.1. Section 4 contains the details of the experimentation, while Section 5 draws some conclusions and addresses future aspects of this research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related Work</head><p>Many different recommending algorithms have been proposed in literature, for example there are techniques based on Bayesian networks <ref type="bibr" target="#b0">[Breese et al., 1998</ref>], Support Vector Machines <ref type="bibr" target="#b1">[Grcar et al., 2005]</ref> and factor analysis <ref type="bibr">[Canny, 2002]</ref>. The most successful and well-known approach to recommender system design is based on collaborative filtering <ref type="bibr" target="#b2">[Sarwar et al., 2001;</ref><ref type="bibr" target="#b2">Shardanand and Maes, 1995]</ref>. In collaborative filtering, each user collaborates with others to establish the quality of products by providing his/her opinion on a set of products. Also, a similarity measure between users is defined by comparing the profiles of different users. In order to suggest a product to an "active user", the recommender system selects the items among those scored by similar customers. The similarity measure is often computed using the Pearson-r correlation coefficient between users (e.g. in <ref type="bibr">[Sar- war et al., 2001]</ref>). Recently a graph based approach has been proposed in <ref type="bibr" target="#b0">[Fouss et al., 2005]</ref>. Fouss et al. compared different scoring algorithm to compute a preference ranking of products (in that case movies) to suggest to a group of users. In this paper the problem has been modeled as a bipartite graph, where nodes are users (people node) and movies (movie node), and there is a link connecting a people node u i to a movie node m j if and only if u i watched movie m j , in this case arcs are undirected and can be weighted according to user preferences expressed about watched movies. Authors tested many different algorithms using a wide range of similarity measures in order to rank movies according to user preferences, some of the most interesting methods are:</p><p>Average Commute Time (CT). This is a distance measure between a pair of nodes i and j in a graph, we denote it as n(i, j), it is defined as the average number of steps that a random walker 2 going across a given graph, starting in the state corresponding to node i, will take to enter state j for the first time and go back to i. If we measure this distance between people and movie nodes in the given bipartite graph, we can use this score to perform the movie ranking.</p><p>Principal Component Analysis based on Euclidean Commute Time Distance (PCA CT). From the eigenvector decomposition of L + , that is the pseudoinverse of the Laplacian matrix (L) corresponding to the graph, it is possible to map nodes into a new Euclidean space that preserves the Euclidean Commute Time Distance, it is also possible to project to a m-dimensional subspace by performing a PCA and keeping a given number of principal components. Then distances computed between nodes in the reduced space can be used to rank the movies for each person.</p><p>Pseudoinverse of the Laplacian Matrix (L + ). Matrix L a similarity measure between nodes of a graph integrating indirect paths, based on the matrix-forest theorem. Similarity measures based on random-walk models have been considered in <ref type="bibr">[White and Smyth, 2003]</ref>, where average first-passage time has been used as a similarity measure between nodes. In collaborative recommendation field is also interesting to consider different metrics described in <ref type="bibr" target="#b0">[Brand, 2005]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Problem</head><p>Formally, a recommender system deals with a set of users u i , i = 1, . . . , U n and a set of products p j , j = 1, . . . , P n , and its goal consists of computing, for each pair: u i , p j , a scor¨º r i,j that measures the expected interest of users u i for product p j on the basis of a knowledge base containing a set of preferences expressed by some users about products. So we need a scoring algorithm to rank products/items for every given user according to its expected preferences, then a recommender system will suggest to a user top-ranked items with respect to personalized ordering. In this section we present the data model we adopted and MovieLens data set, that is a widely used benchmark to evaluate scoring algorithms applied to recommender systems. Our choice with respect to the data model and the data set is not restrictive since it reflect a very common scenario while dealing with recommender systems. In the following we will indifferently make use of terms such as item, product and movie depending on the context, but obviously the proposed algorithm is a general purpose scoring algorithm and it does not matter which kind of items we are ranking in a particular scenario, moreover we will also use the notation m j to refer a product p j in the particular case of movies to be ranked.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">MovieLens Data Set</head><p>+ is the matrix containing the inner products of the node vectors in the Euclidean space where the nodes are exactly separated by the ECTD, so l + i,j can be used as the similarity measure between node i and j, in order to rank movies according to their similarity with the person.</p><p>In literature there are many other examples of algorithms using graphical structures in order to discover relationships between items. Chebotarev and Shamis proposed in <ref type="bibr">[Cheb- otarev and Shamis, 1997]</ref> and <ref type="bibr" target="#b0">[Chebotarev and Shamis, 1998]</ref> MovieLens site has over 50, 000 users who have expressed opinions on more than 3, 000 different movies. The MovieLens dataset is a standard dataset constructed from the homonym site archive, by considering only users who rated 20 or more movies, in order to achieve a greater reliability for user profiling. The dataset contains over 100, 000 ratings from 943 users for 1, 682 movies. Every opinion is represented using a tuple: t i,j = (u i , m j , r i,j ), where t i,j is the considered tuple, u i ¡Ê U is an user, m j ¡Ê M is a movie, and r i,j is a integer score between 1 (bad movie) and 5 (good movie). The database provides a set of features characterizing users and movies which include: the category of the movie, the age, gender, and occupation of the user, and so on. The dataset comes with five predefined splitting, each uses 80% of the ratings for the training set and 20% for the test set (as described in <ref type="bibr" target="#b2">[Sarwar et al., 2002]</ref>). For every standard splitting we call L and T respectively the set of tuples used for training and for testing, moreover we refer the set of movies in the training set rated by user u i as L ui and we write T ui for movies in the test set. More formally:</p><formula xml:id="formula_0">L ui = {t k,j ¡Ê L : k = i} and T ui = {t k,j ¡Ê T : k = i}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Data Model: Correlation Graph</head><p>2 see <ref type="bibr">[Norris, 1997]</ref> for more details</p><p>Even from a superficial analysis of the proposed problem, it seems to be clear that there is a different correlation degree</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IJCAI-07</head><p>between movies, if we could exploit this information from the training set then it would be quite easy to compute user dependent preferences. We define U i,j ? U the set of users who watched (according to the training set) both movie m i and m j , so:</p><formula xml:id="formula_1">U i,j = {u k : (t k,i ¡Ê L u k ) ¡Ä (t k,j ¡Ê L u k )} if i = j ? if i = j</formula><p>Now we compute the (|M |¡Á|M |) matrix containing the number of users who watched each pair of movies:</p><p>attenuation properties we need, furthermore thanks to significant research efforts we can compute PageRank in a very efficient way (see <ref type="bibr" target="#b2">[Kamvar et al., 2003a]</ref>). Consider a generic graph G = (V, E), where V is the set of nodes connected by directed links in E, the classic PageRank algorithm computes an importance score P R(n) for every node n ¡Ê V according to graph connectivity: a node will be important if it is connected to important nodes with a low out-degree. So the PageRank score for node n is defined as:</p><formula xml:id="formula_2">P R(n) = ¦Á ¡¤ ? C i,j = |U i,j | P R(q) ¦Ø q + (1 ? ¦Á) ¡¤ 1 |V| (1) q:(q,n)¡ÊE</formula><p>where |¡¤| denotes the cardinality of a set, obviously ?i, ? C i,i = 0 and?Cand? and?C is a symmetric matrix. We normalize matrix?Cmatrix? matrix?C in order to obtain a stochastic matrix</p><formula xml:id="formula_3">C i,j = ? Ci,j</formula><p>where ¦Ø q is the out-degree of node q, ¦Á is a decay factor 3 . The equivalent matrix form of equation 1 is: ¦Øj where ¦Ø j is the sum of entries in j ? th column of?Cof? of?C. C is the Correlation Matrix, every entry contains the correlation index between movie pairs. The Correlation Matrix can be also considered as a weighted connectivity matrix for the Correlation Graph G C . Nodes in graph G C correspond to movies in M and there will be an edge (m i , m j ) if and only if C i,j &gt; 0. Moreover the weight associated to link (m i , m j ) will be C i,j , note that while?Cwhile? while?C is symmetrical, C is not, so the weight associated to (m i , m j ) can differ from (m j , m i ) weight. The Correlation Graph is a valuable graphical model useful to exploit correlation between movies, weights associated to links provide an approximate measure of movie/movie relative correlation, according to information extracted from ratings expressed by users in the training set.</p><formula xml:id="formula_4">PR = ¦Á ¡¤ C ¡¤ PR + (1 ? ¦Á) ¡¤ 1 |V| ¡¤ 1 |V| (2)</formula><p>where C is the normalized connectivity matrix for graph G and 1 |V| is a |V| long vector of ones. PageRank can also be computed iterating equation 2, for example by applying the Jacobi method <ref type="bibr">[Golub and Loan, 1996]</ref>, even if iteration should be run until PageRank values convergence, we can also use a fixed number I of iterations. Classic PageRank can be extended by generalizing equation 2:</p><formula xml:id="formula_5">PR = ¦Á ¡¤ M ¡¤ PR + (1 ? ¦Á) ¡¤ d<label>(3)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">ItemRank Algorithm</head><p>The idea underlying the ItemRank algorithm is that we can use the model expressed by the Correlation Graph to forecast user preferences. For every user in the training set we know the ratings he assigned to a certain number of movies, that is L ui , so, thanks to the graph G C we can "spread" user preferences through the Correlation Graph. Obviously we have to properly control the preference flow in order to transfer high score values to movies that are strongly related to movies with good ratings. The spreading algorithm we apply has to possess two key properties: propagation and attenuation. These properties reflect two key assumptions. First of all if a movie m k is related to one or more good movies, with respect to a given user u i , then movie m k will also be a good suggestion for user u i , if we analyse the Correlation Graph we can easily discover relationships between movies and also the strength of these connections, that is the weight associated to every link connecting two movies. The second important factor we have to take into account is attenuation. Good movies have to transfer their positive influence through the Correlation Graph, but this effect decrease its power if we move further and further away from good movies, moreover if a good movie m i is connected to two or more nodes, these have to share the boosting effect from m i according to the weights of their connections as computed in matrix C. PageRank algorithm (see <ref type="bibr" target="#b2">[Page et al., 1998</ref>]) has both propagation and where M is a stochastic matrix, its non-negative entries has to sum up to 1 for every column, and vector d has nonnegative entries summing up to 1. Vector d can be tuned in order to bias the PageRank by boosting nodes corresponding to high value entries and matrix M controls the propagation and attenuation mode. Biased PageRank has been analysed in <ref type="bibr" target="#b2">[Langville and Meyer, 2003</ref>] and custom static score distribution vectors d have been applied to compute topic-sensitive PageRank <ref type="bibr" target="#b2">[Haveliwala, 2002]</ref>, reputation of a node in a peerto-peer network <ref type="bibr" target="#b2">[Kamvar et al., 2003b]</ref> and for combating web spam <ref type="bibr" target="#b2">[Gyongyi et al., 2004]</ref>. We present the ItemRank algorithm, that is a biased version of PageRank designed to be applied to a recommender system. ItemRank equation can be easily derived from equation 3. We use graph G C to compute a ItemRank value IR ui for every movie node and for every user profile. In this case the stochastic matrix M will be the Correlation Matrix C and for every user u i we compute a different IR ui by simply choosing a different d ui static score distribution vector. The resulting equation is:</p><formula xml:id="formula_6">IR ui = ¦Á ¡¤ C ¡¤ IR ui + (1 ? ¦Á) ¡¤ d ui<label>(4)</label></formula><p>where d ui has been built according to user u i preferences as recorded in training set L ui . The unnormalized?dunnormalized? unnormalized?d ui , with respect to the j ? th component, is defined as:</p><formula xml:id="formula_7">? d j ui = 0 if t i,j ¡Ê L ui r i,j if t i,j ¡Ê L ui ¡Ä t i,j = (u i , m j , r i,j ) 3 A common choice for ¦Á is 0.85</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IJCAI-07 2768?So</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2768?</head><p>2768?So the normalized d ui vector will simply be</p><formula xml:id="formula_8">d ui = du i | ? du i | .</formula><p>ItemRank, as defined in equation 4, can be computed also iteratively in this way: IR ui (0) = easy happen while the number of users increase), some optimized methods to partially overcome these limitations has been proposed in <ref type="bibr" target="#b0">[Brand, 2005]</ref>.</p><formula xml:id="formula_9">1 4 Experimental Results |M| ¡¤ 1 |M| IR ui (t + 1) = ¦Á ¡¤ C ¡¤ IR ui (t) + (1 ? ¦Á) ¡¤ d ui<label>(5)</label></formula><p>This dynamic system has to be run for every user, luckily it only needs on average about 20 iterations to converge. The interpretation of IR ui score vector for user u i is straightforward, ItemRank scores induce a sorting of movies according to their expected liking for a given user. The higher is the ItemRank for a movie, the higher is the probability that a given user will prefer it to a lower score movie.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Complexity Issues</head><p>ItemRank algorithm results to be very efficient both from computational and memory resource usage point of view. We need to store a |M | nodes graph with a limited number of edges. The interesting fact is that graph G C contains edges (m i , m j ) and (m j , m i ) if and only if ?u k : t k,i ¡Ê L u k ¡Ä t k,j ¡Ê L u k , so no matter the number of users satisfying the previous condition, ratings information will be compressed in just a couple of links anyway. It is interesting to note that the data structure we use scale very well with the increase of the number of users, in fact G C node set cardinality is independent from |U| and also the number of edges tend to increase very slowly after |U| has exceeded a certain threshold ? U. That is a very useful property, because in a real applicative scenario the number of users for a certain e-commerce service and the number of expressed preferences about products will rise much faster than the total amount of offered products. Moreover ItemRank computation is very efficient, thanks to its strong relationship with PageRank algorithm, and we only need about 20 iterations of system 5 for every user in order to rank every movie according to every user taste, so if we have |U| users we have to run the algorithm |U| different times. ItemRank is more efficient than similar Random-Walk based approach such as CT and L + (already introduced in subsection 1.1, see <ref type="bibr" target="#b0">[Fouss et al., 2005]</ref> for details), in fact both CT and L + require to handle a graph containing nodes representing users and products and edges referred to user preferences. So in this graph there are |U| + |M| nodes and two edges (u i , m j ),(m j , u i ) for every opinion (u i , m j , r i,j ), while in the case of ItemRank you have only |M| nodes and ratings information is compressed. CT is used to rank every movie with respect to every system user, so the average commute time (CT) n(u i , m j ) referred to any user-movie couple u i , m j has to be computed, but n(u i , m j ) = m(u i |m j ) + m(m j |u i ) where m(u i |m j ) denotes the average first-passage time from node u i to node m j . So CT needs 2 ¡¤|U|¡¤|M| average first-passage time computations, while ItemRank has to be applied only |U| times to rank every movie with respect to its similarity to every user. The situation is similar also if we consider L + algorithm, in this case, as stated in <ref type="bibr" target="#b0">[Fouss et al., 2005]</ref>, the direct computation of the pseudoinverse of the Laplacian matrix L becomes intractable if the number of nodes becomes large (that could To evaluate the performances of the ItemRank algorithm, we ran a set of experiments on the MovieLens data set, described in subsection 2.1. The choice of this particular data set is not restrictive, since it is a widely used standard benchmark for recommender system techniques and its structure is typical of the most common applicative scenarios. In fact we can apply ItemRank every time we have a set of users (U) rating a set of items or products (I that is the generic notation for M), if we can model our recommendation problem this way (or in any equivalent form) it will be possible to use ItemRank to rank items according to user preferences. We chose an experimental setup and performance index that is the same as used in <ref type="bibr" target="#b0">[Fouss et al., 2005]</ref>, this way we can directly compare our algorithm with some of the most promising scoring algorithms we found in related literature (CT, L + and so on), having many points of contact with ItemRank "philosophy". We split MovieLens data set as described in <ref type="bibr" target="#b2">[Sarwar et al., 2002]</ref>, in order to obtain 5 different subsets, then we applied ItemRank 5 times (5-fold cross validation). Each time, one of the 5 subsets is used as the test set and the remaining 4 sub sets have been merged to form a training set. At the end we computed the average result across all 5 trials. So we have 5 splittings, each uses 80% of the ratings for the training set (that is 80, 000 ratings) and 20% for the test set (the remaining 20, 000 ratings), that is exactly the same way tests have been performed in <ref type="bibr" target="#b0">[Fouss et al., 2005]</ref>. The performance index we used is the degree of agreement (DOA), which is a variant of Somers'D (see <ref type="bibr" target="#b2">[Siegel and Castellan, 1988]</ref> for further details). DOA is a way of measuring how good is an item ranking (movie ranking in MovieLens case) for any given user. To compute DOA for a single user u i we need to define a set of movies N W ui ? M that is the set of movies that are not in the training set, nor in the test set for user u i , so:</p><formula xml:id="formula_10">N W ui = M \ (L ui ¡È T ui )</formula><p>Now we define the boolean function check order as:</p><formula xml:id="formula_11">mj check order ui (m j , m k ) = 1 if IR ui ¡Ý IR m k ui 0 if IR mj ui &lt; IR m k ui</formula><p>where IR mj ui is the score assigned to movie m j with respect to user u i preferences, by the algorithm we are testing. Then we can compute individual DOA for user u i , that is:</p><formula xml:id="formula_12">DOA ui = (j¡ÊTu i , k¡ÊN W u i ) check order ui (m j , m k ) |T ui | ¡¤ |N W ui |</formula><p>So DOA ui measures for user u i the percentage of movie pairs ranked in the correct order with respect to the total number of pairs, in fact a good scoring algorithm should rank the movies that have indeed been watched in higher positions than movies that have not been watched. A random ranking produces a degree of agreement of 50%, half of all the pairs are in correct order and the other half in bad order. An ideal</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IJCAI-07</head><p>ranking correspond to a 100% DOA. Two different global degree of agreement can be computed considering ranking for individual users: Macro-averaged DOA and micro-averaged DOA. The Macro-averaged DOA (or shortly Macro DOA) will be the average of individual degree of agreement for every user, so:</p><formula xml:id="formula_13">Macro DOA = ui¡ÊU DOA ui |U|</formula><p>The micro-averaged DOA (or shortly micro DOA) is the ratio between the number of movie pairs in the right order (for every user) and the total number of movie pairs checked (for every user), so it can be computed as:</p><formula xml:id="formula_14">+ (j¡ÊTu i , k¡ÊN Wu i ) check orderu i (m j , m k )</formula><p>briefly described some of these algorithms in subsection 1.1, for further details see <ref type="bibr" target="#b0">[Fouss et al., 2005]</ref>. For every tested algorithm we provide Macro DOA index, that has been computed for every technique as the average result across all 5 trials of 5-fold cross-validation. Moreover we provide the difference (in %) with performance obtained by the trivial MaxF algorithm and the standard deviation (STD) of this quantity. MaxF is our baseline for the task, it is a user independent scoring algorithm, it simply ranks the movies by the number of persons who watched them, movies are suggested to each person in order of decreasing popularity. So MaxF produces the same ranking for all the users. ItemRank performs better than any other considered technique obtaining +3.69 with respect to the baseline and a very good standard deviation (0.31 In addition it is worth to note that ItemRank is less complex than other proposed algorithms with respect to memory usage and computational cost too, as already argued in subsection 3.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions</head><p>binary version of?Cof? of?C ( ? C bin ), so we have:</p><formula xml:id="formula_15">C bin i,j = ? C bin i,j</formula><p>¦Øj where?C where? where?C bin i,j can be computed as:</p><formula xml:id="formula_16">? C bin i,j = 1 if U i,j &gt; 0 0 if U i,j = 0</formula><p>In other words if we compute ItemRank with binary graph, we are weighting every correlation edge connecting two items in the same way, no matter the number of co-occurrences in user preference lists for these items, since C bin i,j correspond to the weight of edge (m i , m j ) in the Correlation Graph G C we use for information propagation. <ref type="table">Table 1</ref> clearly shows the usefulness of a properly weighted Correlation Matrix C compared to C bin . This table provides both Macro and micro DOA for every split and for ItemRank and its simplified version with binary graph: ItemRank clearly works much better when we use a proper Correlation Matrix. For example, if we look at Macro DOA mean values, ItemRank with Correlation Matrix C obtain +15.43 points (in %) with respect to C bin version. These are interesting results because they confirm our main hypothesis: ItemRank algorithm ranks items according to the information extracted from the Correlation Matrix (that is equivalent to the weighted Correlation Graph) and the way we compute C entries is really able to properly model relationships among evaluated items. Finally table 2 shows a performance comparison among different scoring algorithm applied to MovieLens data set. We In this paper, we present a random-walk based scoring algorithm, which can be used to recommend products according to user preferences. We compared our algorithm with other state-of-the-art ranking techniques on MovieLens data set. ItemRank performs better than the other algorithms we compared to and, at the same time, it is less complex than other proposed algorithms with respect to memory usage and computational cost too. Future research topics include the experimentation of the algorithm on different applications. We are now working on a extension of ItemRank. The version presented so far is able to handle the recommendation task as a item scoring/ranking problem. But we can face the problem from the regression point of view too. So we expect ItemRank 2.0 will also be able to produce expected satisfaction prediction for a given recommendation, other than product ranking.  [ <ref type="bibr" target="#b0">Chebotarev and Shamis, 1998</ref>] P. Chebotarev and E. Shamis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ItemRank</head><p>On proximity measures for graph vertices. Automation and Remote Control, 59(10):14431459, 1998.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table 2 : Comparison among different scoring algorithm applied to MovieLens data set.</head><label>2</label><figDesc></figDesc><table></table></figure>

			<note place="foot" n="1"> http://www.movielens.umn.edu IJCAI-07</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>Many thanks to Giuliano Testa for running the experiments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A novel way of computing dissimilarities between nodes of a graph, with application to collaborative filtering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Brand ; Breese</surname></persName>
		</author>
		<idno>1997. IJCAI-07</idno>
	</analytic>
	<monogr>
		<title level="m">A random walks perspective on maximizing satisfaction and profit. In 2005 SIAM International Conference on Data Mining</title>
		<imprint>
			<publisher>Johns Hopkins University Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page">133151</biblScope>
		</imprint>
	</monogr>
	<note>Eigentaste: A constant time collaborative filtering algorithm. Golub and Loan, 1996] G. Golub and C. Van Loan. Matrix Computations. The. third edition</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Knn versus svm in the collaborative filtering framework</title>
	</analytic>
	<monogr>
		<title level="m">ACM WebKDD 2005 Taming evolving, Expanding and Multi-faceted Web Clickstreams Workshop</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Grouplens for usenet: Experiences in applying collaborative filtering to a social information system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Gyongyi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Ninth ACM SIGKDD International Conference on Knowledge Discovery and Data mining</title>
		<editor>C. Leug and D. Fisher</editor>
		<imprint>
			<publisher>McGraw-Hill</publisher>
			<date type="published" when="1988" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">2771</biblScope>
		</imprint>
		<respStmt>
			<orgName>Stanford University ; Stanford University</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical report</note>
	<note>Fifth International Conference on Computer and Information Technology</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
