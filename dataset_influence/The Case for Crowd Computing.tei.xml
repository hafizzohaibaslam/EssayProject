<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 D:\grobid-master\grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.1-SNAPSHOT" ident="GROBID" when="2018-07-17T00:06+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The case for crowd computing</title>
			</titleStmt>
			<publicationStmt>
				<publisher>ACM Press</publisher>
				<availability status="unknown"><p>Copyright ACM Press</p>
				</availability>
				<date type="published" when="2010-01">January 2010 May 2016</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Derek</forename><forename type="middle">G</forename><surname>Murray</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eiko</forename><surname>Yoneki</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jon</forename><surname>Crowcroft</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Hand</surname></persName>
						</author>
						<title level="a" type="main">The case for crowd computing</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the second ACM SIGCOMM workshop on Networking, systems, and applications on mobile handhelds - MobiHeld &apos;10</title>
						<meeting>the second ACM SIGCOMM workshop on Networking, systems, and applications on mobile handhelds - MobiHeld &apos;10						</meeting>
						<imprint>
							<publisher>ACM Press</publisher>
							<date type="published" when="2010-01">January 2010 May 2016</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/1851322.1851334</idno>
					<note>See discussions, stats, and author profiles for this publication at: https://www.researchgate.net/publication/221164357 Conference Paper ¡¤ 4 authors, including: 84 PUBLICATIONS 2,149 CITATIONS SEE PROFILE All in-text references underlined in blue are linked to publications on ResearchGate, letting you access and read them immediately. Available from: Eiko Yoneki Retrieved on: 31</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C14 [Processor Architectures]: Parallel Architectures-mobile processors General Terms Algorithms</term>
					<term>Measurement Keywords Distributed computation</term>
					<term>human mobility</term>
					<term>task farming</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We introduce and motivate crowd computing, which combines mobile devices and social interactions to achieve large-scale distributed computation. An opportunistic network of mobile devices offers substantial aggregate bandwidth and processing power. In this paper , we analyse encounter traces to place an upper bound on the amount of computation that is possible in such networks. We also investigate a practical task-farming algorithm that approaches this upper bound, and show that exploiting social structure can dramatically increase its performance.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Today's smartphone is a powerful computer. It is equipped with a range of sensors, a gigahertz-range CPU and high-bandwidth wireless networking capabilities <ref type="bibr" target="#b2">[5]</ref>. Inspired by the increasing prevalence of smartphones, and research into opportunistic networking <ref type="bibr">[4,</ref><ref type="bibr" target="#b16">19]</ref>, we have evaluated the potential of using these devices to carry out large-scale distributed computations. In this paper, we introduce crowd computing, in which opportunistic networks can be used to spread computation and collect results.</p><p>A crowd computation spreads opportunistically through a network, using ad-hoc wireless connections that form as devices come into proximity. The devices can exchange input data and intermediate results. In parallel work, we are developing programming languages that enable developers to implement a crowd computation <ref type="bibr" target="#b14">[17,</ref><ref type="bibr" target="#b22">25]</ref>; this paper focuses on the aggregate utility of such a computation, in terms of how much work each device can carry out.</p><p>Why is crowd computing attractive? Previous work has shown that people will voluntarily contribute their desktop computer resources for running scientific workloads <ref type="bibr" target="#b3">[6]</ref>. We could imagine a similar application for mobile devices that provides free content or functionality in exchange for volunteered cycles. Furthermore, unusual devices such as graphics cards <ref type="bibr" target="#b17">[20]</ref> and games consoles <ref type="bibr" target="#b1">[3]</ref> have been used to perform high-throughput computing. A modern smartphone has several special-purpose cores (such as DSPs and A/V codecs) <ref type="bibr" target="#b2">[5]</ref>, which could similarly be applied to large-scale problems. Moreover, opportunistic networks in which the nodes are mobile offer potentially huge bandwidth <ref type="bibr" target="#b7">[10]</ref>, turning a collection of smartphones into a mobile supercomputer.</p><p>Alternatively, we can use crowd computing as a means of distributing human interaction tasks to mobile devices. For example, Amazon Mechanical Turk has created a marketplace for carrying out work that is difficult for computers to process, but relatively simple for humans <ref type="bibr" target="#b0">[1]</ref>. For example, many qualitative classification tasks are much easier for humans than computers, such as "What is the best Sushi restaurant in San Francisco?" By combining this model with crowd computing, it would be possible to exploit geographic locality in the respondents.</p><p>We begin by seeking an upper bound for the computational capacity of an opportunistic network (Section 2). We contrive an idealised distributed computation that can spread epidemically with negligible data exchange, and simulate its execution on a variety of human encounter traces. By positing that each person in the trace possesses a smartphone, we can measure the total work done by simulation.</p><p>Of course, few realistic computations fit our ideal model. We therefore consider the common task farming approach, and evaluate its performance on the same traces (Section 3). We find that, on average, it achieves 40% of the performance of our ideal computation. Switching to a concrete model introduces more variables, so we consider the effect of master choice, task size and node capacity on the overall utility of the system.</p><p>We build on previous work that has shown how social network analysis can greatly improve the efficiency of message forwarding in opportunistic networks <ref type="bibr" target="#b4">[7,</ref><ref type="bibr" target="#b8">11]</ref>. We investigate how a similar technique can be used to improve the performance of task farming (Section 4). In particular, we observe that dividing an opportunistic network into communities, and running a separate task farm within each community, improves the throughput of task farming by an average of 50%.</p><p>In this paper, we aim to show that an opportunistic network of mobile devices is an interesting platform for distributed computation. Our results demonstrate that such networks can provide a high degree of parallelism. We are currently developing the first crowd computing applications that exploit this approach.  </p><formula xml:id="formula_0">¦Á 0 ¦Ø 0 ¦Á 2 ¦Ø 2 35 ¦Ó 0 ¦Ó 2</formula><formula xml:id="formula_1">Algorithm 1 Algorithm for computing ¦Ái A ¡û {0} ¦Á0 ¡û start time for (i, j, t) ¡Ê trace do if i ¡Ê A ¡Ä j / ¡Ê A then ¦Áj ¡û t, A ¡û A ¡È {j} else if j ¡Ê A ¡Ä i / ¡Ê A then ¦Ái ¡û t, A ¡û A ¡È {i} end if end for</formula><p>Finally, at time ¦Ø0, the initiator ends the computation 2 , and computes the final result from the messages that it has received. Now consider device i. It starts computing at ¦Ái. At ¦Øi, it sends the last message that (in one or more hops) reaches the initiator before ¦Ø0. An encounter is a tuple (i, j, t), indicating that nodes i and j meet at time t. Given a chronologically-ordered sequence of encounters, we compute ¦Ái using Algorithm 1. We compute ¦Øi by reversing the order of the encounter trace, and rerunning Algorithm 1 (substituting ¦Ø for ¦Á).</p><p>Device i is useful for duration ¦Ói, defined as follows:</p><formula xml:id="formula_2">¦Ói = ? ¦Øi ? ¦Ái if ¦Ái &lt; ¦Øi 0 otherwise (1)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BEST CASE SCENARIO</head><p>We first determine an upper bound for the amount of computation achievable in an opportunistic network. The goal of a crowd computation is to have long periods of useful parallelism. This means that a device must not only receive a message that causes it to join the computation, but it must send a message containing its result that eventually reaches the initiator <ref type="figure" target="#fig_0">(Figure 1</ref>). In this section, we first define our model of an ideal distributed computation ( ¡ì2.1), and then evaluate it on real-world encounter traces ( ¡ì2.2).</p><p>In the ideal case, each cycle spent on the computation has constant utility. Therefore the utility of a device, ui = ¦Ói, and the overall utility, U = P i ui. In order to achieve this, each device must be given enough work to occupy it fully between ¦Ái and ¦Øi. This requires either an omniscient scheduler or a computation that can be repeated ad infinitum. Monte Carlo simulation is an example of the latter case. We evaluate a simple scheduler design in Section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Real-world traces</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Definitions</head><p>We assume a set of n identical mobile devices that participate in the computation. Device zero is the initiator, and starts computing (becomes active) at time ¦Á0.</p><p>For optimal delivery, coordination and result messages spread by flooding. All devices listen for radio transmissions at all times; all active devices continually broadcast a probe message to discover nearby devices <ref type="bibr" target="#b0">1</ref> . When an active device meets another device, they exchange a sequence of messages. First, the active device sends a message describing the computation. On receiving this message, an inactive device becomes active: thus the computation floods throughout the network. Each active device stores a partial result that includes the result of its computation, and any partial results received from other devices. When two devices meet, they exchange their current partial result: this ensures that the results also flood through the network, which maximises the probability that they reach the initiator.</p><p>We now evaluate the upper bound for several real-world scenarios, by applying the above algorithm to several human encounter traces. In this and the following sections, we use traces from various sources. These traces can be obtained from CRAWDAD <ref type="bibr">[2]</ref>:</p><p>MIT In the MIT Reality Mining project, 97 smart phones were deployed to students and staff at MIT over a period of 9 months <ref type="bibr" target="#b6">[9]</ref>.</p><p>Cambridge In the Haggle project, 36 iMotes were deployed to 1st year and 2nd year undergraduate students at the University of Cambridge for 10 days <ref type="bibr">[4]</ref>.</p><p>Infocom 78 iMotes were deployed at the Infocom 2006 conference for 3 days.</p><p>In our first experiment, we consider the lifespan of a single computation. We simulate the execution of an ideal computation on the whole Cambridge trace, choosing each device in turn as the initiator. We record two metrics: the number of useful devices at time   putations, binned into hours of the day. There is a period of approximately 10 hours each day when the utility is dramatically greater, including two hours of very high utility, which correspond to the peak lecture hours when most participants would be colocated.  t, P (t), and the total utility of the computation, U = R ¦Ø 0 ¦Á 0 P (t) dt. <ref type="figure" target="#fig_1">Figure 2</ref> shows how P (t) changes throughout the simulation, for the best, worst and average case. Note that the best case has at least 26 devices doing useful work until shortly before the end of the computation, whereas in the worst case, the initiator does not see any other devices after the halfway point of the computation. The average case achieves 93% of the best case total utility.</p><p>We now investigate the properties of different traces. Since each trace has a different duration and number of devices, we must normalise U in order to compare traces. <ref type="figure" target="#fig_2">Figure 3</ref> shows CDFs of utility for the Cambridge, MIT and Infocom traces, normalised by the length of the trace and number of devices. Each trace exhibits different performance. The MIT trace has the worst performance, which we suspect is due to the relatively infrequent encounters between devices in a diverse group of participants <ref type="bibr" target="#b6">[9]</ref>. By contrast, the participants in the Cambridge and Infocom traces were more homogeneous (all computer science undergraduates or conference attendees), and hence more likely to occupy the same space.</p><p>The amount of useful computation depends greatly on the choice of the initiator, which we investigate further in Section 4. The choice of start time (¦Á0) and finish time (¦Ø0) also have a predictable effect: running a computation at night or at the weekend, when encounters are rarer, leads to less parallelism and less utility. We ran one million simulated computations each lasting one hour, with the start time and initiator chosen uniformly at random, using the Cambridge trace. <ref type="figure" target="#fig_6">Figure 4</ref> shows the average utility of these comIn order to build a practical system for mobile distributed computation, we require a realistic scheme for achieving parallelism. In this section, we consider task farming as one possible scheme. We simulate the effect of task farming on several encounter traces, and evaluate its performance with respect to the upper bounds established in the previous section.</p><p>Task farming is the basis of many distributed computing systems, including Condor <ref type="bibr" target="#b19">[22]</ref>, BOINC <ref type="bibr" target="#b3">[6]</ref>, MapReduce <ref type="bibr" target="#b5">[8]</ref> and Dryad <ref type="bibr" target="#b10">[13]</ref>. In all of these systems, a single master process manages a queue of tasks, and distributes these amongst an ensemble of worker processes. When a worker completes a task, it requests another from the master. The algorithm naturally handles worker failure and load balancing <ref type="bibr" target="#b18">[21]</ref>. Task farming is therefore an obvious candidate for distributing work in our crowd computing system. We modify our model of distributed computation as follows. The overall job can be decomposed into a large number of atomic, independent tasks, which have a constant duration, d. The initiator acts as the master, which maintains a (potentially infinite) queue of tasks to be executed. All other devices are workers, which maintain a local queue of length c, and can process a task every d seconds. When the master meets a worker, it fills the worker's queue with up to c new tasks and collects the results of completed tasks. A successful task is one that has been processed by the worker and the result of which has been communicated to the master. (N.B. We assume that a useful result can be obtained from any subset of task results: however tasks may be lost, in which case task replication <ref type="bibr" target="#b3">[6]</ref> or encoding <ref type="bibr" target="#b13">[16]</ref> techniques may be appropriate.)</p><p>We simulated the execution of a task farming computation for the Cambridge, MIT and Infocom traces, choosing each node in turn as master. In these experiments, we set d = 100 seconds and c = ¡Þ, which is the optimal configuration as no node will ever be idle once activated. We will discuss the effect of varying c and d later in this section. The utility of the task farming computation is simply the number of successful tasks multiplied by d. We can therefore compute the ratio of the task farming utility to the best-case utility for each configuration, which gives us a measure of efficiency. <ref type="figure" target="#fig_3">Figure 5</ref> shows the CDFs of efficiency for the Cambridge, MIT and Infocom traces. Note that, as in <ref type="figure" target="#fig_2">Figure 3</ref>, the Cambridge and Infocom traces Realistically, our devices will have finite capacity (c), and the duration of tasks (d) may be longer than 100 seconds. There are two main challenges when setting these parameters. A short queue may lead to a device becoming idle if it exhausts all of its tasks before meeting the master again. We can partly address this by increasing d, but note that a task duration that is much longer than the master-worker inter-contact time means that opportunities to retrieve task results will be missed. <ref type="figure">Figure 6</ref> shows how varying c and d affects the overall amount of successful work in the Cambridge trace. The optimal utility is achieved with c = 10 4 and d = 100, which is equivalent to c = ¡Þ, since it would take longer than the trace duration to exhaust such a queue. Setting c = 1 never yields more than 45% of the optimal utility. However, the configuration c = 10, d = 10 5 gives 92% of the optimal utility, while offering much greater flexibility and consuming fewer resources. We note that this is a large and complicated parameter space, and further investigation is required to set the parameters optimally.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SOCIAL-AWARE TASK FARMING</head><p>We can improve the efficiency of distributed computation by exploiting the social network formed by human interaction. Previous work has looked at the influence of graph structure <ref type="bibr" target="#b4">[7]</ref> and community detection <ref type="bibr" target="#b8">[11]</ref> on the efficiency of opportunistic networks used for communication. In this section, we investigate the use of community structure to improve the overall utility of a computation.</p><p>In the model of Section 3, the master communicates directly with the workers, so it must encounter them. Therefore, we naturally prefer to choose a master that meets a large number of other devices. If we had a single master, we might choose the device that meets the greatest number of devices in the most recent time period. However, human interaction exhibits community structure: the set of devices can be partitioned into groups that are highly connected, while having relatively few connections between groups <ref type="bibr" target="#b15">[18]</ref>. Therefore, our na?ve approach would achieve many successful task results from nodes in the same community as the master, but few from other communities.</p><p>If we knew the community structure, we could exploit it by assigning one master node to each community. We would also modify the task farming algorithm slightly so that workers only accept tasks from a master if it is in the same community. We expect that this would improve the overall utility of the system, because the community structure makes it more likely that a master will meet its worker again to collect the results 3 . The Cambridge data set has two communities: each is a different class of undergraduate students <ref type="bibr" target="#b21">[24]</ref>. We divided the devices into their respective communities, and simulated task farming (i) using all nodes as workers, and (ii) using only nodes in the same community as the master. In both cases, c = ¡Þ and d = 100 seconds. <ref type="figure">Figure 7</ref> shows the total utility in both cases, for each possible master. We see that, on average, 78% of the successful tasks are computed by nodes in the same community.</p><p>Our improved algorithm would choose one master from each community. We simulate this by computing the number of successful tasks for each pair of nodes in different communities. <ref type="figure" target="#fig_9">Figure 8</ref> shows that we should expect two randomly-chosen per-community masters to outperform a randomly-chosen global master. On average, per-community masters complete 49% more tasks than a single master, and 62% of the community-aware configurations outperform the best global master.</p><p>The main limitation of this scheme is that there are now two masters that collect partial results, and we have not specified a way for them to communicate-indeed, they might never meet. We therefore require a protocol that enables the collection of a single, global result. One approach is to rely on a deus ex machina: we could give the master nodes access to some infrastructure-such as a satellite telephone-that enables them to communicate; or, if it is available, we could allow the masters to communicate over the cellular network. A more intellectually-satisfying approach would be to use opportunistic forwarding to exchange synchronising messages between the masters <ref type="bibr" target="#b16">[19]</ref>. Both these solutions are costly (either in real money or extra bandwidth), and the cost increases with the number of masters, so this gives a natural trade-off between the performance of the system and its cost.</p><p>In this section, we have considered only simple task farming policies, and several enhancements are possible. For example, we could allow worker nodes to act as masters for other devices that they meet, and thereby build a spanning tree through the entire network. We could run an adaptive algorithm that selects the optimal nodes as masters and migrates the state as necessary. Indeed, if the computation decomposes spatially <ref type="bibr" target="#b18">[21]</ref>, or into a dependency graph (as in Dryad <ref type="bibr" target="#b10">[13]</ref>), we could attempt to embed the problem domain into the encounter graph itself <ref type="bibr" target="#b22">[25]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">RELATED WORK</head><p>The idea of using mobile devices for parallel computation is relatively new. However, we draw on several related areas of research, which we summarise in this section.</p><p>As noted earlier, several systems achieve distribution and parallelism through task farming. Condor harnesses the idle cycles from a network of desktop workstations, and uses these to run batchsubmitted tasks <ref type="bibr" target="#b19">[22]</ref>. The BOINC project allows volunteers from around the world to process tasks on their desktop computers, for projects such as SETI@home, Folding@home and Climateprediction.net <ref type="bibr" target="#b3">[6]</ref>. Task farming is also used in the data center. Google's MapReduce <ref type="bibr" target="#b5">[8]</ref> and Microsoft's Dryad <ref type="bibr" target="#b10">[13]</ref> both use task farming to schedule parallel processing on large (multi-terabyte) data sets. Each of these programming models could be implemented on top of a task scheduler for crowd computing.</p><p>We recently became aware of Hyrax, which includes a port of MapReduce to the Android operating system <ref type="bibr" target="#b12">[15]</ref>. Hyrax assumes a relatively static cluster and treats device mobility as a problem of fault tolerance; by contrast, we show that it is often advantageous to assume that nodes will meet again in the future.</p><p>The use of network analysis in Section 4 is inspired by previous work in mobile routing. PRoPHET routing uses the history of past encounters in order to make probabilistic decisions about message forwarding <ref type="bibr" target="#b11">[14]</ref>. SimBet routes messages via nodes that are "similar" to the destination, based on their connectivity <ref type="bibr" target="#b4">[7]</ref>. The BUB-BLE Rap algorithm uses community structure to improve message forwarding efficiency in a delay-tolerant (i.e. disconnected) network <ref type="bibr" target="#b8">[11]</ref>. BUBBLE Rap also includes a simple distributed algorithm for community detection, which could be applied to selecting masters in our social-aware task farming system.</p><p>Wireless sensor networks also use mobile devices to perform distributed computation. Directed diffusion combines routing, caching and aggregation for data in a sensor network <ref type="bibr" target="#b9">[12]</ref>. Welsh and Mainland describe a programming model for in-network processing of sensor data in order to reduce the bandwidth consumption <ref type="bibr" target="#b20">[23]</ref>. We anticipate potential synergies between a sensor network that collects data, and a crowd computing system that analyses it. lect results. Furthermore, a simple task farming model can achieve reasonable performance in such a network, and dramatically better performance when community detection is used.</p><p>Due to the lack of space, this paper leaves several questions open. Power consumption is an important consideration: we must ensure that the crowd computation does not drain the mobile devices' batteries. A crowd computation should be energy-efficient, so the amount of wasted work (the results of which never reach the initiator) must be small. We must consider an efficient replication or encoding scheme that compensates for the loss of some results without reducing performance unduly. We intend to investigate these in future work.</p><p>Finally, we have presented only one realistic model for crowd computing: static task farming. Opportunistic networks are highly dynamic, and so we expect that an adaptive system will perform even better. For example, we rely on direct master-worker encounters in order to relay results, but it would be possible to do better by using opportunistic forwarding. In conjunction with the D 3 N project, we are investigating programming models that directly exploit social structure <ref type="bibr" target="#b22">[25]</ref>. Some programming frameworks, such as MapReduce <ref type="bibr" target="#b5">[8]</ref> and Dryad <ref type="bibr" target="#b10">[13]</ref>, allow users to specify dependencies between tasks. This creates an opportunity for new scheduling algorithms that take execution order into account when assigning tasks to workers. We have recently ported our Skywriting runtime <ref type="bibr" target="#b14">[17]</ref> to the Android operating system, and we are investigating how to make it exploit the unique characteristics of mobile devices.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 : The progress of a computation in a network of five nodes. Each arrow corresponds to an encounter between nodes. Bold black lines correspond to useful computation, and bold gray lines correspond to wasted computation.</head><label>1</label><figDesc>Figure 1: The progress of a computation in a network of five nodes. Each arrow corresponds to an encounter between nodes. Bold black lines correspond to useful computation, and bold gray lines correspond to wasted computation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 : Achievable parallelism for an ideal distributed com- putation running on the Cambridge trace.</head><label>2</label><figDesc>Figure 2: Achievable parallelism for an ideal distributed computation running on the Cambridge trace.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 : CDFs of normalised utility for the Cambridge, MIT and Infocom traces.</head><label>3</label><figDesc>Figure 3: CDFs of normalised utility for the Cambridge, MIT and Infocom traces.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 : CDF of task farming efficiency for the Cambridge, MIT and Infocom traces.</head><label>5</label><figDesc>Figure 5: CDF of task farming efficiency for the Cambridge, MIT and Infocom traces.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 : Relative utility for an hour-long job in the Cambridge trace, depending on the hour of the day.</head><label>4</label><figDesc>Figure 4: Relative utility for an hour-long job in the Cambridge trace, depending on the hour of the day.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 : Effect of varying worker queue length (c) and task duration (d) on total successful work done. (Work done is nor- malised to make the optimal case equal to 1 Figure 7 : Comparison of intra-community and global task farming for the Cambridge</head><label>617</label><figDesc>Figure 6: Effect of varying worker queue length (c) and task duration (d) on total successful work done. (Work done is normalised to make the optimal case equal to 1.0.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 : CDFs of successful task count for single-master and per-community master task farming.</head><label>8</label><figDesc>Figure 8: CDFs of successful task count for single-master and per-community master task farming.</figDesc></figure>

			<note place="foot" n="1"> In practice, power considerations and wireless MAC protocols will limit the ability of devices to broadcast continually. 2 The initiator may broadcast ¦Ø0 with the initial announcement in order to reduce the amount of wasted computation: however, this requires synchronised clocks.</note>

			<note place="foot" n="3"> This would also reduce the number of unsuccessful tasks: i.e. those that are processed without the master being notified.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank Malte Schwarzkopf for his constructive comments on a draft of this paper. This research is part-funded by the EU grants for the Haggle project (IST-4-027918) and the SOCIALNETS project (217141); and the EPSRC DDEPI Project, EP/H003959.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">REFERENCES</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSIONS</head><p>In this paper, we have shown preliminary results that indicate the potential for crowd computing. Human interaction can be used to spread computation through an opportunistic network, and col-</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Amazon Mechanical</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Turk</surname></persName>
		</author>
		<ptr target="http://www.mturk.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ps3</forename><surname>Folding@home</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Faq</surname></persName>
		</author>
		<ptr target="http://folding.stanford.edu/English/FAQ-PS3" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Nexus One Phone -Feature overview &amp; Technical Specifications</title>
		<ptr target="http://www.google.com/phone/static/en_US-nexusone_tech_specs.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">BOINC: A system for public-resource computing and storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">P</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th international workshop on Grid Computing</title>
		<meeting>the 5th international workshop on Grid Computing</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Social Network Analysis for Routing in Disconnected Delay-Tolerant MANETs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Daly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Haahr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of MobiHoc</title>
		<meeting>MobiHoc</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">MapReduce: simplified data processing on large clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of OSDI</title>
		<meeting>OSDI</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Reality mining: sensing complex social systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Eagle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pentland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Personal and Ubiquitous Computing</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="255" to="268" />
			<date type="published" when="2006-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Mobility increases the capacity of ad hoc wireless networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Grossglauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">N C</forename><surname>Tse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Netw</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="477" to="486" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">BUBBLE Rap: Social-based Forwarding in Delay Tolerant Networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Crowcroft</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Yoneki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of MobiHoc</title>
		<meeting>MobiHoc</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Directed diffusion for wireless sensor networking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Intanagonwiwat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heidemann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Netw</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Dryad: distributed data-parallel programs from sequential building blocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Isard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Birrell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fetterly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EuroSys</title>
		<meeting>EuroSys</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Probabilistic Routing in Intermittently Connected Networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lindgren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Doria</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Schel¨¦n</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">3126</biblScope>
			<biblScope unit="page" from="239" to="254" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">E</forename><surname>Marinelli</surname></persName>
		</author>
		<title level="m">Hyrax: Cloud Computing on Mobile Devices using MapReduce. Master&apos;s thesis</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Spread-spectrum computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">G</forename><surname>Murray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of HotDep</title>
		<meeting>HotDep</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Scripting the cloud with Skywriting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">G</forename><surname>Murray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of HotCloud</title>
		<meeting>HotCloud</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Finding and evaluating community structure in networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">E J</forename><surname>Newman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Girvan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Phys. Rev. E</title>
		<imprint>
			<biblScope unit="volume">69</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">26113</biblScope>
			<date type="published" when="2004-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Opportunistic networking: Data forwarding in disconnected mobile ad hoc networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Pelusi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Passarella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Conti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Communications Magazine</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="134" to="141" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Optimization principles and application performance evaluation of a multithreaded GPU using CUDA</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ryoo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">I</forename><surname>Rodrigues</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename><surname>Baghsorkhi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename><surname>Stone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">B</forename><surname>Kirk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">W</forename><surname>Hwu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of PPoPP</title>
		<meeting>PPoPP</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Parallel programming models and paradigms. High Performance Cluster Computing: Architectures and Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Buyya</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Distributed computing in practice: the Condor experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Thain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Tannenbaum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Livny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Concurrency: Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2-4</biblScope>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Programming sensor networks using abstract regions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Welsh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Mainland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of NSDI</title>
		<meeting>NSDI</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Visualizing communities and centralities from encounter traces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Yoneki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CHANTS</title>
		<meeting>CHANTS</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">D 3 N: Programming distributed computation in pocket switched networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Yoneki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Baltopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Crowcroft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of MobiHeld</title>
		<meeting>MobiHeld</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
