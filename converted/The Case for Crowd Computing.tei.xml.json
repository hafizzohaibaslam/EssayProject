[
     {
          "head": {
               "n": "0",
               "text": "abstract",
               "type": "abstract"
          },
          "paragraphs": [
               "We introduce and motivate crowd computing, which combines mobile devices and social interactions to achieve large-scale distributed computation. An opportunistic network of mobile devices offers substantial aggregate bandwidth and processing power. In this paper , we analyse encounter traces to place an upper bound on the amount of computation that is possible in such networks. We also investigate a practical task-farming algorithm that approaches this upper bound, and show that exploiting social structure can dramatically increase its performance."
          ],
          "paper_id": "24290890-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 0,
          "fromPaper": "The case for crowd computing"
     },
     {
          "head": {
               "n": "1.",
               "text": "INTRODUCTION",
               "type": "introduction"
          },
          "paragraphs": [
               "Today's smartphone is a powerful computer. It is equipped with a range of sensors, a gigahertz-range CPU and high-bandwidth wireless networking capabilities . Inspired by the increasing prevalence of smartphones, and research into opportunistic networking , we have evaluated the potential of using these devices to carry out large-scale distributed computations. In this paper, we introduce crowd computing, in which opportunistic networks can be used to spread computation and collect results.",
               "A crowd computation spreads opportunistically through a network, using ad-hoc wireless connections that form as devices come into proximity. The devices can exchange input data and intermediate results. In parallel work, we are developing programming languages that enable developers to implement a crowd computation ; this paper focuses on the aggregate utility of such a computation, in terms of how much work each device can carry out.",
               "Why is crowd computing attractive? Previous work has shown that people will voluntarily contribute their desktop computer resources for running scientific workloads . We could imagine a similar application for mobile devices that provides free content or functionality in exchange for volunteered cycles. Furthermore, unusual devices such as graphics cards and games consoles have been used to perform high-throughput computing. A modern smartphone has several special-purpose cores (such as DSPs and A/V codecs) , which could similarly be applied to large-scale problems. Moreover, opportunistic networks in which the nodes are mobile offer potentially huge bandwidth , turning a collection of smartphones into a mobile supercomputer.",
               "Alternatively, we can use crowd computing as a means of distributing human interaction tasks to mobile devices. For example, Amazon Mechanical Turk has created a marketplace for carrying out work that is difficult for computers to process, but relatively simple for humans . For example, many qualitative classification tasks are much easier for humans than computers, such as \"What is the best Sushi restaurant in San Francisco?\" By combining this model with crowd computing, it would be possible to exploit geographic locality in the respondents.",
               "We begin by seeking an upper bound for the computational capacity of an opportunistic network (Section 2). We contrive an idealised distributed computation that can spread epidemically with negligible data exchange, and simulate its execution on a variety of human encounter traces. By positing that each person in the trace possesses a smartphone, we can measure the total work done by simulation.",
               "Of course, few realistic computations fit our ideal model. We therefore consider the common task farming approach, and evaluate its performance on the same traces (Section 3). We find that, on average, it achieves 40% of the performance of our ideal computation. Switching to a concrete model introduces more variables, so we consider the effect of master choice, task size and node capacity on the overall utility of the system.",
               "We build on previous work that has shown how social network analysis can greatly improve the efficiency of message forwarding in opportunistic networks . We investigate how a similar technique can be used to improve the performance of task farming (Section 4). In particular, we observe that dividing an opportunistic network into communities, and running a separate task farm within each community, improves the throughput of task farming by an average of 50%.",
               "In this paper, we aim to show that an opportunistic network of mobile devices is an interesting platform for distributed computation. Our results demonstrate that such networks can provide a high degree of parallelism. We are currently developing the first crowd computing applications that exploit this approach. ",
               "Finally, at time0, the initiator ends the computation 2 , and computes the final result from the messages that it has received. Now consider device i. It starts computing ati. Ati, it sends the last message that (in one or more hops) reaches the initiator before0. An encounter is a tuple (i, j, t), indicating that nodes i and j meet at time t. Given a chronologically-ordered sequence of encounters, we computei using Algorithm 1. We computei by reversing the order of the encounter trace, and rerunning Algorithm 1 (substitutingfor).",
               "Device i is useful for durationi, defined as follows:"
          ],
          "paper_id": "24290890-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 1,
          "fromPaper": "The case for crowd computing"
     },
     {
          "head": {
               "n": "2.",
               "text": "BEST CASE SCENARIO",
               "type": "introduction"
          },
          "paragraphs": [
               "We first determine an upper bound for the amount of computation achievable in an opportunistic network. The goal of a crowd computation is to have long periods of useful parallelism. This means that a device must not only receive a message that causes it to join the computation, but it must send a message containing its result that eventually reaches the initiator ). In this section, we first define our model of an ideal distributed computation (2.1), and then evaluate it on real-world encounter traces (2.2).",
               "In the ideal case, each cycle spent on the computation has constant utility. Therefore the utility of a device, ui =i, and the overall utility, U = P i ui. In order to achieve this, each device must be given enough work to occupy it fully betweeni andi. This requires either an omniscient scheduler or a computation that can be repeated ad infinitum. Monte Carlo simulation is an example of the latter case. We evaluate a simple scheduler design in Section 3."
          ],
          "paper_id": "24290890-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 2,
          "fromPaper": "The case for crowd computing"
     },
     {
          "head": {
               "n": "2.1",
               "text": "Definitions",
               "type": "modelling"
          },
          "paragraphs": [
               "We assume a set of n identical mobile devices that participate in the computation. Device zero is the initiator, and starts computing (becomes active) at time0.",
               "For optimal delivery, coordination and result messages spread by flooding. All devices listen for radio transmissions at all times; all active devices continually broadcast a probe message to discover nearby devices . When an active device meets another device, they exchange a sequence of messages. First, the active device sends a message describing the computation. On receiving this message, an inactive device becomes active: thus the computation floods throughout the network. Each active device stores a partial result that includes the result of its computation, and any partial results received from other devices. When two devices meet, they exchange their current partial result: this ensures that the results also flood through the network, which maximises the probability that they reach the initiator.",
               "We now evaluate the upper bound for several real-world scenarios, by applying the above algorithm to several human encounter traces. In this and the following sections, we use traces from various sources. These traces can be obtained from CRAWDAD :",
               "MIT In the MIT Reality Mining project, 97 smart phones were deployed to students and staff at MIT over a period of 9 months .",
               "Cambridge In the Haggle project, 36 iMotes were deployed to 1st year and 2nd year undergraduate students at the University of Cambridge for 10 days .",
               "Infocom 78 iMotes were deployed at the Infocom 2006 conference for 3 days.",
               "In our first experiment, we consider the lifespan of a single computation. We simulate the execution of an ideal computation on the whole Cambridge trace, choosing each device in turn as the initiator. We record two metrics: the number of useful devices at time  putations, binned into hours of the day. There is a period of approximately 10 hours each day when the utility is dramatically greater, including two hours of very high utility, which correspond to the peak lecture hours when most participants would be colocated. t, P (t), and the total utility of the computation, U = R00 P (t) dt. shows how P (t) changes throughout the simulation, for the best, worst and average case. Note that the best case has at least 26 devices doing useful work until shortly before the end of the computation, whereas in the worst case, the initiator does not see any other devices after the halfway point of the computation. The average case achieves 93% of the best case total utility.",
               "We now investigate the properties of different traces. Since each trace has a different duration and number of devices, we must normalise U in order to compare traces. shows CDFs of utility for the Cambridge, MIT and Infocom traces, normalised by the length of the trace and number of devices. Each trace exhibits different performance. The MIT trace has the worst performance, which we suspect is due to the relatively infrequent encounters between devices in a diverse group of participants . By contrast, the participants in the Cambridge and Infocom traces were more homogeneous (all computer science undergraduates or conference attendees), and hence more likely to occupy the same space.",
               "The amount of useful computation depends greatly on the choice of the initiator, which we investigate further in Section 4. The choice of start time (0) and finish time (0) also have a predictable effect: running a computation at night or at the weekend, when encounters are rarer, leads to less parallelism and less utility. We ran one million simulated computations each lasting one hour, with the start time and initiator chosen uniformly at random, using the Cambridge trace. shows the average utility of these comIn order to build a practical system for mobile distributed computation, we require a realistic scheme for achieving parallelism. In this section, we consider task farming as one possible scheme. We simulate the effect of task farming on several encounter traces, and evaluate its performance with respect to the upper bounds established in the previous section.",
               "Task farming is the basis of many distributed computing systems, including Condor , BOINC , MapReduce and Dryad . In all of these systems, a single master process manages a queue of tasks, and distributes these amongst an ensemble of worker processes. When a worker completes a task, it requests another from the master. The algorithm naturally handles worker failure and load balancing . Task farming is therefore an obvious candidate for distributing work in our crowd computing system. We modify our model of distributed computation as follows. The overall job can be decomposed into a large number of atomic, independent tasks, which have a constant duration, d. The initiator acts as the master, which maintains a (potentially infinite) queue of tasks to be executed. All other devices are workers, which maintain a local queue of length c, and can process a task every d seconds. When the master meets a worker, it fills the worker's queue with up to c new tasks and collects the results of completed tasks. A successful task is one that has been processed by the worker and the result of which has been communicated to the master. (N.B. We assume that a useful result can be obtained from any subset of task results: however tasks may be lost, in which case task replication or encoding techniques may be appropriate.)",
               "We simulated the execution of a task farming computation for the Cambridge, MIT and Infocom traces, choosing each node in turn as master. In these experiments, we set d = 100 seconds and c =, which is the optimal configuration as no node will ever be idle once activated. We will discuss the effect of varying c and d later in this section. The utility of the task farming computation is simply the number of successful tasks multiplied by d. We can therefore compute the ratio of the task farming utility to the best-case utility for each configuration, which gives us a measure of efficiency. shows the CDFs of efficiency for the Cambridge, MIT and Infocom traces. Note that, as in , the Cambridge and Infocom traces Realistically, our devices will have finite capacity (c), and the duration of tasks (d) may be longer than 100 seconds. There are two main challenges when setting these parameters. A short queue may lead to a device becoming idle if it exhausts all of its tasks before meeting the master again. We can partly address this by increasing d, but note that a task duration that is much longer than the master-worker inter-contact time means that opportunities to retrieve task results will be missed. shows how varying c and d affects the overall amount of successful work in the Cambridge trace. The optimal utility is achieved with c = 10 4 and d = 100, which is equivalent to c =, since it would take longer than the trace duration to exhaust such a queue. Setting c = 1 never yields more than 45% of the optimal utility. However, the configuration c = 10, d = 10 5 gives 92% of the optimal utility, while offering much greater flexibility and consuming fewer resources. We note that this is a large and complicated parameter space, and further investigation is required to set the parameters optimally. "
          ],
          "paper_id": "24290890-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 3,
          "fromPaper": "The case for crowd computing"
     },
     {
          "head": {
               "n": "4.",
               "text": "SOCIAL-AWARE TASK FARMING",
               "type": "modelling"
          },
          "paragraphs": [
               "We can improve the efficiency of distributed computation by exploiting the social network formed by human interaction. Previous work has looked at the influence of graph structure and community detection on the efficiency of opportunistic networks used for communication. In this section, we investigate the use of community structure to improve the overall utility of a computation.",
               "In the model of Section 3, the master communicates directly with the workers, so it must encounter them. Therefore, we naturally prefer to choose a master that meets a large number of other devices. If we had a single master, we might choose the device that meets the greatest number of devices in the most recent time period. However, human interaction exhibits community structure: the set of devices can be partitioned into groups that are highly connected, while having relatively few connections between groups . Therefore, our na?ve approach would achieve many successful task results from nodes in the same community as the master, but few from other communities.",
               "If we knew the community structure, we could exploit it by assigning one master node to each community. We would also modify the task farming algorithm slightly so that workers only accept tasks from a master if it is in the same community. We expect that this would improve the overall utility of the system, because the community structure makes it more likely that a master will meet its worker again to collect the results 3 . The Cambridge data set has two communities: each is a different class of undergraduate students . We divided the devices into their respective communities, and simulated task farming (i) using all nodes as workers, and (ii) using only nodes in the same community as the master. In both cases, c =and d = 100 seconds. shows the total utility in both cases, for each possible master. We see that, on average, 78% of the successful tasks are computed by nodes in the same community.",
               "Our improved algorithm would choose one master from each community. We simulate this by computing the number of successful tasks for each pair of nodes in different communities. shows that we should expect two randomly-chosen per-community masters to outperform a randomly-chosen global master. On average, per-community masters complete 49% more tasks than a single master, and 62% of the community-aware configurations outperform the best global master.",
               "The main limitation of this scheme is that there are now two masters that collect partial results, and we have not specified a way for them to communicate-indeed, they might never meet. We therefore require a protocol that enables the collection of a single, global result. One approach is to rely on a deus ex machina: we could give the master nodes access to some infrastructure-such as a satellite telephone-that enables them to communicate; or, if it is available, we could allow the masters to communicate over the cellular network. A more intellectually-satisfying approach would be to use opportunistic forwarding to exchange synchronising messages between the masters . Both these solutions are costly (either in real money or extra bandwidth), and the cost increases with the number of masters, so this gives a natural trade-off between the performance of the system and its cost.",
               "In this section, we have considered only simple task farming policies, and several enhancements are possible. For example, we could allow worker nodes to act as masters for other devices that they meet, and thereby build a spanning tree through the entire network. We could run an adaptive algorithm that selects the optimal nodes as masters and migrates the state as necessary. Indeed, if the computation decomposes spatially , or into a dependency graph (as in Dryad ), we could attempt to embed the problem domain into the encounter graph itself ."
          ],
          "paper_id": "24290890-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 4,
          "fromPaper": "The case for crowd computing"
     },
     {
          "head": {
               "n": "5.",
               "text": "RELATED WORK",
               "type": "relatedwork"
          },
          "paragraphs": [
               "The idea of using mobile devices for parallel computation is relatively new. However, we draw on several related areas of research, which we summarise in this section.",
               "As noted earlier, several systems achieve distribution and parallelism through task farming. Condor harnesses the idle cycles from a network of desktop workstations, and uses these to run batchsubmitted tasks . The BOINC project allows volunteers from around the world to process tasks on their desktop computers, for projects such as SETI@home, Folding@home and Climateprediction.net . Task farming is also used in the data center. Google's MapReduce and Microsoft's Dryad both use task farming to schedule parallel processing on large (multi-terabyte) data sets. Each of these programming models could be implemented on top of a task scheduler for crowd computing.",
               "We recently became aware of Hyrax, which includes a port of MapReduce to the Android operating system . Hyrax assumes a relatively static cluster and treats device mobility as a problem of fault tolerance; by contrast, we show that it is often advantageous to assume that nodes will meet again in the future.",
               "The use of network analysis in Section 4 is inspired by previous work in mobile routing. PRoPHET routing uses the history of past encounters in order to make probabilistic decisions about message forwarding . SimBet routes messages via nodes that are \"similar\" to the destination, based on their connectivity . The BUB-BLE Rap algorithm uses community structure to improve message forwarding efficiency in a delay-tolerant (i.e. disconnected) network . BUBBLE Rap also includes a simple distributed algorithm for community detection, which could be applied to selecting masters in our social-aware task farming system.",
               "Wireless sensor networks also use mobile devices to perform distributed computation. Directed diffusion combines routing, caching and aggregation for data in a sensor network . Welsh and Mainland describe a programming model for in-network processing of sensor data in order to reduce the bandwidth consumption . We anticipate potential synergies between a sensor network that collects data, and a crowd computing system that analyses it. lect results. Furthermore, a simple task farming model can achieve reasonable performance in such a network, and dramatically better performance when community detection is used.",
               "Due to the lack of space, this paper leaves several questions open. Power consumption is an important consideration: we must ensure that the crowd computation does not drain the mobile devices' batteries. A crowd computation should be energy-efficient, so the amount of wasted work (the results of which never reach the initiator) must be small. We must consider an efficient replication or encoding scheme that compensates for the loss of some results without reducing performance unduly. We intend to investigate these in future work.",
               "Finally, we have presented only one realistic model for crowd computing: static task farming. Opportunistic networks are highly dynamic, and so we expect that an adaptive system will perform even better. For example, we rely on direct master-worker encounters in order to relay results, but it would be possible to do better by using opportunistic forwarding. In conjunction with the D 3 N project, we are investigating programming models that directly exploit social structure . Some programming frameworks, such as MapReduce and Dryad , allow users to specify dependencies between tasks. This creates an opportunity for new scheduling algorithms that take execution order into account when assigning tasks to workers. We have recently ported our Skywriting runtime to the Android operating system, and we are investigating how to make it exploit the unique characteristics of mobile devices."
          ],
          "paper_id": "24290890-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 5,
          "fromPaper": "The case for crowd computing"
     }
]