[
     {
          "head": {
               "n": "0",
               "text": "abstract",
               "type": "abstract"
          },
          "paragraphs": [
               "A model for autonomy-based multi-agent systems aimed at exhibiting emerging properties is proposed. Then, the prerequisites for a distributed implementation are discussed. A preliminary distributed implementation , illustrated by an application to a robotics simulation, is consequently sketched with a strong emphasis on STL, our coordination model, whose aim is to provide powerful coordination mechanisms that do not alter the model's conceptual prescriptions. concept of emergence of behavior and/or functional-ity. Emergence ooers indeed a bridge between the necessity of complex and adaptive behavior at a macro level and the mechanisms of multiple competences and situation-based learning at a micro level. A system's behavior can be considered emergent if it can only be speciied using descriptive categories which are not to be used to describe the behavior of the constituent components. 2 Our Multi-Agent Model"
          ],
          "paper_id": "2193dec0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 0,
          "fromPaper": "Autonomous Agents: from Concepts to Implementation"
     },
     {
          "head": {
               "n": "1",
               "text": "Introduction",
               "type": "introduction"
          },
          "paragraphs": [
               "Artiicial Intelligence (AI) aims at synthesizing intelligence in artefacts. However two families of approaches exist disagreeing in their notion of what intelligence actually means , . On the one hand, Top-Down AI considers intelligence as the capacity to form and manipulate internal representational models of the world. On the other hand, Bottom-Up AI (or Autonomous Agents) considers intelligence as a biological feature this notion is often referred to as Enactivism.",
               "There is a vast number of papers dealing with Autonomous Agents. Our aim is not to go through all of them in depth, but rather to brieey introduce the necessary notions with which our work is related. Autonomous agents are by deenition considered to be embodied systems (for the diierent forms of embodiment, see for instance , P. , and ). They are designed to fullll internal or external goals by their own actions in continuous longterm interaction with the environment (possibly unpredictable and dynamical) in which they are situated. Dealing with interactions leads naturally to the Pa r t o f t h i s w ork is supported by the Swiss National Foundation for Scientiic Research, grants 21-Our model for autonomy-based multi-agent systems is composed of an Environment and a list of Agents. The Environment encompasses a list of Cells and a set of Objects which will be manipulated by the agents. Every Cell contains a list of Neighbour Cells, which implicitly sets the topology, and the set of objects actually available on it at a given time.",
               "The architecture of an agent is displayed on 1. An agent possesses some sensors to perceive the world within which it moves, and some eeectors to act in this world, so that it complies with the prescriptions of physically embodied agents and simulated embodied agents . The implementation of the different modules presented on , namely Perception, State, Actions and Control Algorithm depends on the application and is the user's responsibility. In the Perception module, the designer speciies the type of perception of the agent, e.g. if the agent perceives only the number of objects on the cell on which it stands. The State module encompasses the private information of the agent, e.g. whether it carries or not an object, its strain or whatever. The Actions module typically consists of the basic actions the agent can take, e.g. move to next cell, pick u p a n object or drop an object. The Control Algorithm module is particularly important because it deenes the type of autonomy o f the agent: it is precisely inside this module that the designer decides whether to implement an operational autonomy or a behavioral autonomy . Operational autonomy is deened as the capacity to operate without human intervention, without being 43558.95 and 21-47262.96 remotely controlled. Behavioral autonomy supposes that the basis of self-steering originates in the agent's own capacity to form and adapt its principles of behavior: an agent,tobebehaviorally autonomous, does not only need the freedom to behave/operate without human intervention (operational autonomy), but further the freedom to have formed (learned or decided) its principles of behavior on its own (from its experience), at least partly.",
               "can run simultaneously on diierent nodes, and which have to be synchronized somehow (e.g. by message exchanges) in order to collect some (intermediate) results. Such applications do not fully convey the notion of proper time for each process, and moreover they do not aim at: thus, processes are embedded in a static coordination structure, where the slower process imposes its time (temporality) to the system (faster processes have indeed to wait for the slower process when synchronizing each others). Our concern is rather diierent. As previously stated, temporality features identity and autonomy: an entity is not anymore autonomous when its temporality is subsumed to an external time scale. We h a ve therefore to identify some coordination patterns that will not alter every agent's temporality and behavior, and we have to develop corresponding tools and primitives. Our platform must be able to render to some extent the independence in space and time, without being interfered by coordination mechanisms exclusively embedded for a purpose of implementation.",
               "3 Distributed Implementation 3.1 The Model's Prerequisites"
          ],
          "paper_id": "2193dec0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 1,
          "fromPaper": "Autonomous Agents: from Concepts to Implementation"
     },
     {
          "head": {
               "text": "Overview",
               "type": "introduction"
          },
          "paragraphs": [
               "Our multi-agent model is aimed at addressing problems which are naturally distributed (both in space and time). In our model, agents coexist (in space and time) and share a common environment. Moreover, agents can move, act in parallel in the environment, each one having its own freedom for deciding. This implies a certain independence between agents in the system and between areas of the environment. Moreover, it is assumed that each agent has its own time or temporality, which is peculiar to its identity. To e xpress our autonomy-based multi-agent model on a distributed architecture in the most natural way, w e n e e d an appropriate software platform in which the implementation would be the image of the model (the concepts) with the highest We need some tools allowing us to coordinate our autonomous agents (since they interact in their environment) while preserving their structure and their behavior, like for instance their degree of autonomy.",
               "If the problem of spatially coexisting agents is straightforward to be implemented on a distributed system (computation units are already spatially distributed), the problem of coexisting in time (temporality for each agent in the system) should be given a great consideration. In distributed systems, time is usually subordinated to space. Generally, distributed applications capitalize on the property of spatial distribution of services, e.g. two independent processes that can be executed in parallel on two nodes in order to improve the performance. Distributed applications are most of the time made up of processes which Today's state of the art parallel programming models used for implementing general purpose distributed applications suuer from limitations concerning a clean separation of the computational part and the \\glue\" that coordinates the overall distributed application. Especially these limitations make a distributed implementation of autonomy-based multi-agent models, our concern, a burdensome task. To study problems related to coordination, Malone ] introduced a new theory called coordination theory aimed at deening such a \\glue\". The key issue of coordination is managing dependencies among activities. To formalize and better describe these interdependencies it is necessary to separate the computation and the coordination of a parallel application N. . The research in this area has led to the deenition of several coordination models and corresponding coordination languages, whose most prominent representative is . Other models and languages are based on message passing paradigms , object-oriented techniques , m ulti-set rewriting schemes Ban^ atre and M etayer, 1993] or control-driven models . Blops, as an abstraction and modularization mechanism for processes and ports. It serves as a separate name space as well as an encapsulation mechanism for events. Blops have the same interface as processes, i.e., a name and a set of ports. The creation of blops is handled in the same way as the creation of processes. It includes the initialization of all processes and ports deened for this blop and subordinated blops. Processes, as a representation of active entities. A process is a typed object, it has a name and a set of ports. Processes in STL do not know any kind of process identiication, instead a black box process model is used. Process termination is implicit.",
               "The Coordination Media of STL are the following: events, ports and connections serve as the medium which enables coordination, a n d a b l o p is the medium in which coordination takes placee Ports, as the interface of processes/blops to the external world. Every communication in STL is handled via a connection which is the result of ports matching. A port has a name and a set of well deened attributes: they are referred to as the port's signature. The Coordination Laws are deened through the semantics of the Coordination Tools and the semantics of the interactions with the coordination media by means of events.",
               "STL materializes the separation of concern as it uses a separate language exclusively reserved for coordination purposes and provides primitives which are used in the computation language to interact with the entities to be coordinated. As far as the implementation of these primitives is concerned, we u s e Pt-pvm a s o f t ware platform for programming multi-threaded applications on a cluster of workstations as the underlying communication and process management platform."
          ],
          "paper_id": "2193dec0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 2,
          "fromPaper": "Autonomous Agents: from Concepts to Implementation"
     },
     {
          "head": {
               "n": "3.3",
               "text": "Application of STL",
               "type": "introduction"
          },
          "paragraphs": [
               "The Framework Events, as a mechanism to dynamically react to state changes within a blop. They can be triggered using a condition operation on a port. STL provides some conditions such as unbound, isfull or accessed. Connections, as a representation of connected ports. Their semantics depend on the port types. According to the general characteristics of what makes up a coordination model and corresponding coordination language, these elements are classiied in the following way:",
               "The Coordination Entities of STL are the processes of the distributed application, implemented as threadss Our model is used for a simulation in the framework of mobile robotics and more speciically collective robotics. Our application tackles a quite common problem in collective robotics which is still give n a l o t of consideration: agents are in charge of regrouping objects distributed in their environment. The innovative aspect of our approach rests indeed on a system integrating operationally autonomous agents: every agent i n the system has the freedom to act on a cell (the agent decides by itself which action to take). Therefore, there is not in the system any t ype of master responsible for supervising the agents, nor any t ype of cooperation protocol, thus allowing the system to be more and fault tolerant.",
               "We implemented a serial version of this simulation in the Swarm Simulation System , stressing on the measurement of quantitative results and on the realization of appropriate visualization tools to follow in real-time the run of an experiment. We implemented several variants for agent modules and realized an intensive number of experiments whereof we observed an implicit cooperation between the agents in the system to accomplish a global task, i.e. regrouping objects. In such an experiment, the location of the stack c o n taining the objects at the end of the run is the result of the agents' interactions. Details on the implementation and results can be found in F. and . A preliminary implementation of this simulation in a real world involving real mobile robots (kheperas) exhibited the emergence of cooperation. platform (implementation purpose), namely initAgent and taxi, and processes that are intrinsic to the multiagent model, namely subEnv and agent processes."
          ],
          "paper_id": "2193dec0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 3,
          "fromPaper": "Autonomous Agents: from Concepts to Implementation"
     },
     {
          "head": {
               "text": "A Preliminary STL-based Implementation",
               "type": "relatedwork"
          },
          "paragraphs": [
               "For this preliminary implementation, the Environment is made up of a torus grid with a four connectivity (each cell has four neighbors). Agents comply rigorously with the model previously introduced . They sense the environment through their sensors and act upon their perception at once.",
               "To p u t to good use distributed systems, the Environment is split into sub-environments, each of which being handled by a blop, thus providing an independent functioning between sub-environments. Note that blops have to be arranged in accordance with the topology of the environment they implement. "
          ],
          "paper_id": "2193dec0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 4,
          "fromPaper": "Autonomous Agents: from Concepts to Implementation"
     },
     {
          "head": {
               "text": "PORTS north_o north_i south_o south_i west_o west_i east_o east_i i_SubEnv i_Agents, VALUES name n s w e) { P2P_o north_o(n)) P2P_i north_i(n)) P2P_o south_o(s)) P2P_i south_i(s)) P2P_o west_o(w))",
               "type": "relatedwork"
          },
          "paragraphs": [
               "P2P_i west_i(w)) P2P_o east_o(e)) P2P_i east_i(e)) P2P_i i_SubEnv(\"INIT-SE-\" + name)) P2P_i i_Agents(\"INIT-A-\" + name)) process initAgent(PORTS newArrival init) { P2P_iN newArrival(\"INIT-A-\" + name, n, s, w, e)) P2P_oN init(\"AGENT-INIT\")) } process agent(PORTS req_ans creation) { P2P_i creation(\"AGENT-INIT\")) BB req_ans(\"SUBENV-AGENT\")) } process subEnv(PORTS init in_out to_taxi) { P2P_i init(\"INIT-SE-\" + name)) BB in_out(\"SUBENV-AGENT\")) P2P_o to_taxi(\"TAXI\")) } process taxi(PORTS tNorth tSouth tWest tEast requ) { P2P_o tNorth(n)) P2P_o tSouth(s)) P2P_o tWest(w)) P2P_o tEast(e)) P2P_i requ(\"TAXI\")) } event newAgentEvt { create process agent aa when accessed(i.newArrival) then newAgentEvtt } create process subEnv envv create process taxi txx create process initAgent ii when accessed(i.newArrival Global Structure. The meta-blop world is comp o s e d o f a n init process, responsible for the global initialization of the system, and a set of predeened blops (called se), each one handling a sub-environment.",
               "The init process has two static ports (of type P2P o) for every blop to be initialized . The r^ ole of the init process is twofold: to create through its cre Agts port the initial agents within every blopp secondly, to set up through its cre SubEnv port the sub-environment (size, number of objects, etc.) of every blop.",
               "ports: four P2P o out--owing direction ports(north o, south o, west o, east o) and four P2P i in--owing direction ports (north i, south i, west i, east i), which are used for agent migration, and two P2P i ports, namely i Agents and i SubEnv used respectively for the creation of the initial agents and for the initialization of the subEnv process.",
               "For the time being, the topology between blops is set in a static manner, by creating the ports with appropriate names. The four in--owing direction ports of a blop match with ports of its inner process initAgent. The four out--owing direction ports of a blop match with ports of its inner process taxi. initAgent Process, newAgentEvt Event. The Blop se. shows the basic organization of processes within a blop se and their coordination through ports. displays the implementation of se in STL. Two t ypes of processes may b e distinguished: processes that are part of the coordination initAgent process is responsible for the creation of agents. It has two static ports: newArrival and init. The newArrival P2P iN port is connected to all inowing direction ports of the blop within which it resides. As soon as a value comes to this port, the initAgent process copies it onto its init P2P oN port. In the meantime, the newAgentEvt event (see ",
               "Msg stateTp(state)) // Message boolean noMigration = TRUEE creation.get(0, stateTp))// Initialize while (noMigration) { // Perception/Action req = make_req()) Msg requestTp(\"request\", req->id, *req)) req_ans.put(0, requestTp)) // Put request Msg answerTp(\"answer\", req->id, answer)) req_ans.get(0, answerTp)) // Get answer control(answer)) // Control Algorithm state = update_state(answer)) noMigration = migrate_p(answer)) } P2P_o to_taxii // For migration to_taxi.port_export(\"MIG\" + req->id)) to_taxi.put(0, stateTp)) // Transfer state exit ) // To taxi } and then inform the taxi process an agent has to be migrated (the direction the agent h a s t o t a k e w i l l b e transmitted).",
               "The taxi Process. The taxi process is responsi- : Implementation of agent in C++.",
               "ble for migrating agents across blops' boundaries. It has four static direction ports (of type P2P o), which are connected to the four out--owing direction ports of the blop within which it stands. When this process receives on its static P2P i port requ the direction towards where the agent has to migrate, it will create a dynamic P2P i port con Agt in order to establish with the appropriate agent process a communication, by means of which it will collect all the useful information of the agent ( state). These values will then be written on the port corresponding to the direction to take and will be transferred to the newArrival port of the initAgent process of the concerned blop inducing the dynamic creation of a new agent process in the blop, thus materializing the migration. 4) is triggered and it will create a new agent process, which through its creation port will read the value that was previously written on the init port of the initAgent process. Transmitted values are for instance the state of the agent to create. As already stated, this process reads on its creation port some values (its state). All req ans ports of the agents are connected to a Blackboard, through which a g e n ts will sense their environment ( perception) and act into it (action), by performing put/get operations (Linda-like out/in) with appropriate messages. The type of action depends on the type of control Algorithm implemented within the agent (see ). The to taxi port is used to communicate dynamically with the taxi process in case of migration: the state of the agent is indeed copied to the taxi process. The decision of migrating is always taken by the subEnv process. subEnv Process. The subEnv process handles the access to the sub-environment and is in charge of keeping data consistency. It is also responsible for migrating agents, which will cross the border of a subenvironment. It has a static in out port (of type BB) connected to the Blackboard and a static P2P o port to taxi connected to the taxi process. Once initialized through its init P2P i port, the subEnv process builds the sub-environment. By performing put/get operations with appropriate tuples, the subEnv process will process the requests of the agents (e.g. number of objects on a given cell, move to next cell) and reply to their requests (e.g. x objects on a given cell, move registered). When the move o f a n a g e n t will lead to cross the border (cell located in another blop), the subEnv process will rst inform the agent it has to migrate We presented a model for autonomy-based multi-agent systems and its prerequisites for parallelization. We built a coordination platform based on STL's coordination model on top of the existing Pt-pvm platform . We s k etched a preliminary STL-based distributed implementation of our multiagent model applied to a collective robotics simulation. STL showed its power and demonstrated its appropriateness for coordinating a generic class of autonomous agents, whose most critical constraint i s t h e preservation of temporality b y dismissing coordination mechanisms exclusively embedded for purpose of implementation.",
               "There are two major outcomes to this work. First, as autonomous agents' systems are aimed at addressing problems which are naturally distributed, our coordination platform provides a user the possibility t o have an actual distributed implementation and therefore to beneet from the numerous advantages of distributed systems, making this work a step forward in the Autonomous Agents community. Secondly, a s t h e generic patterns of coordination for autonomy-based multi-agent implementations are embedded within the platform, a user can quite easily develop new applications (e.g. by c hanging the type of autonomy o f the agents, the ty p e o f e n vironment), insofar they comply with the generic model.",
               "Future works are as follows. First, a graphical user interface will be developed in order to facilitate the speciication of the coordination part of a distributed application. Secondly, the basic mechanisms of STL have to be enhanced in order to simplify the expression of the coordination and to establish a well deened semantics. Thirdly, the implementation of STL is still to be carried on in two w ays: as a separate coordination language and as a coordination library. Fourthly, t h e STL coordination model is still to be extended in order to encompass as many as possible generic patterns of coordination, yielding in STL templates at disposal for general purpose implementations. In our study, w e focused only on operational autonomy in an engineering approach. Future works will consist in studying behavioral autonomy through learning approaches."
          ],
          "paper_id": "2193dec0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 5,
          "fromPaper": "Autonomous Agents: from Concepts to Implementation"
     }
]