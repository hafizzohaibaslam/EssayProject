[
     {
          "head": {
               "n": "0",
               "text": "abstract",
               "type": "abstract"
          },
          "paragraphs": [
               "This paper surveys the of reinforcement learning from a computer-science perspective. It is written to be accessible to researchers familiar with machine learning. Both the historical basis of the and a broad selection of current w ork are summarized. Reinforcement learning is the problem faced by an agent that learns behavior through trial-and-error interactions with a dynamic environment. The work described here has a resemblance to work in psychology, but diiers considerably in the details and in the use of the word The paper discusses central issues of reinforcement learning, including trading oo exploration and exploitation, establishing the foundations of the via Markov decision theory, learning from delayed reinforcement, constructing empirical models to accelerate learning, making use of generalization and hierarchy, and coping with hidden state. It concludes with a survey of some implemented systems and an assessment of the practical utility of current methods for reinforcement learning."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 0,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "1.",
               "text": "Introduction",
               "type": "introduction"
          },
          "paragraphs": [
               "Reinforcement learning dates back to the early days of cybernetics and work in statistics, psychology, neuroscience, and computer science. In the last to ten years, it has attracted rapidly increasing interest in the machine learning and artiicial intelligence communities. Its promise is beguiling|a way of programming agents by reward and punishment without needing to specify how the task is to be achieved. But there are formidable computational obstacles to fulllling the promise.",
               "This paper surveys the historical basis of reinforcement learning and some of the current work from a computer science perspective. We give a high-level overview of the and a taste of some speciic approaches. It is, of course, impossible to mention all of the important work in the this should not be taken to be an exhaustive account.",
               "Reinforcement learning is the problem faced by an agent that must learn behavior through trial-and-error interactions with a dynamic environment. The work described here has a strong family resemblance to eponymous work in psychology, but diiers considerably in the details and in the use of the word It is appropriately thought o f a s a class of problems, rather than as a set of techniques.",
               "There are two main strategies for solving reinforcement-learning problems. The is to search in the space of behaviors in order to one that performs well in the environment. This approach has been taken by w ork in genetic algorithms and genetic programming, as well as some more novel search techniques . The second is to use statistical techniques and dynamic programming methods to estimate the utility of taking actions in states of the world. This paper is devoted almost entirely to the second set of techniques because they take advantage of the special structure of reinforcement-learning problems that is not available in optimization problems in general. It is not yet clear which set of approaches is best in which circumstances.",
               "The rest of this section is devoted to establishing notation and describing the basic reinforcement-learning model. Section 2 explains the trade-oo between exploration and exploitation and presents some solutions to the most basic case of reinforcement-learning problems, in which w e w ant to maximize the immediate reward. Section 3 considers the more general problem in which rewards can be delayed in time from the actions that were crucial to gaining them. Section 4 considers some classic model-free algorithms for reinforcement learning from delayed reward: adaptive heuristic critic, TD and Q-learning. Section 5 demonstrates a continuum of algorithms that are sensitive to the amount of computation an agent can perform between actual steps of action in the environment. Generalization|the cornerstone of mainstream machine learning research|has the potential of considerably aiding reinforcement learning, as described in Section 6. Section 7 considers the problems that arise when the agent does not have complete perceptual access to the state of the environment. Section 8 catalogs some of reinforcement learning's successful applications. Finally, Section 9 concludes with some speculations about important open problems and the future of reinforcement learning."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 1,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "1.1",
               "text": "Reinforcement-Learning Model",
               "type": "modelling"
          },
          "paragraphs": [
               "In the standard reinforcement-learning model, an agent is connected to its environment via perception and action, as depicted in . On each step of interaction the agent receives as input, i, some indication of the current state, s, of the environment; the agent then chooses an action, a, to generate as output. The action changes the state of the environment, and the value of this state transition is communicated to the agent through a scalar reinforcement signal, r. The agent's behavior, B, should choose actions that tend to increase the long-run sum of values of the reinforcement signal. It can learn to do this over time by systematic trial and error, guided by a wide variety of algorithms that are the subject of later sections of this paper. Formally, the model consists of a discrete set of environment states, S; a discrete set of agent actions, A; and a set of scalar reinforcement signals; typically f0; 1g, or the real numbers.",
               "The also includes an input function I, which determines how the agent views the environment state; we will assume that it is the identity function that is, the agent perceives the exact state of the environment until we consider partial observability in Section 7.",
               "An intuitive w ay to understand the relation between the agent and its environment i s with the following example dialogue. . . .",
               ". . .",
               "The agent's job is to a policy , mapping states to actions, that maximizes some long-run measure of reinforcement. We expect, in general, that the environment will be non-deterministic; that is, that taking the same action in the same state on two diierent occasions may result in diierent next states anddor diierent reinforcement v alues. This happens in our example above: from state 65, applying action 2 produces diiering reinforcements and diiering states on two occasions. However, we assume the environment i s stationary; that is, that the probabilities of making state transitions or receiving speciic reinforcement signals do not change over time. Reinforcement learning diiers from the more widely studied problem of supervised learning in several ways. The most important diierence is that there is no presentation of inputtoutput pairs. Instead, after choosing an action the agent is told the immediate reward and the subsequent state, but is not told which action would have been in its best long-term interests. It is necessary for the agent to gather useful experience about the possible system states, actions, transitions and rewards actively to act optimally. Another diierence from supervised learning is that on-line performance is important: the evaluation of the system is often concurrent with learning.",
               "Some aspects of reinforcement learning are closely related to search and planning issues in artiicial intelligence. AI search algorithms generate a satisfactory trajectory through a graph of states. Planning operates in a similar manner, but typically within a construct with more complexity than a graph, in which states are represented by compositions of logical expressions instead of atomic symbols. These AI algorithms are less general than the reinforcement-learning methods, in that they require a predeened model of state transitions, and with a few exceptions assume determinism. On the other hand, reinforcement learning, at least in the kind of discrete cases for which theory has been developed, assumes that the entire state space can be enumerated and stored in memory|an assumption to which conventional search algorithms are not tied."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 2,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "1.2",
               "text": "Models of Optimal Behavior",
               "type": "modelling"
          },
          "paragraphs": [
               "Before we can start thinking about algorithms for learning to behave optimally, w e h a ve to decide what our model of optimality will be. In particular, we h a ve to specify how the agent should take the future into account in the decisions it makes about how to behave now. There are three models that have been the subject of the majority o f w ork in this area.",
               "The nite-horizon model is the easiest to think about; at a given moment in time, the agent should optimize its expected reward for the next h steps: it need not worry about what will happen after that. In this and subsequent expressions, r t represents the scalar reward received t steps into the future. This model can be used in two w ays. In the the agent will have a non-stationary policy; that is, one that changes over time. On its step it will take what is termed a h-step optimal action. This is deened to be the best action available given that it has h steps remaining in which to act and gain reinforcement. On the next step it will take a h , 1-step optimal action, and so on, until it takes a 1-step optimal action and terminates. In the second, the agent does receding-horizon control, in which i t a l w ays takes the h-step optimal action. The agent always acts according to the same policy, but the value of h limits how far ahead it looks in choosing its actions. The model is not always appropriate. In many cases we m a y not know the precise length of the agent's life in advance. The innnite-horizon discounted model takes the long-run reward of the agent i n to account, but rewards that are received in the future are geometrically discounted according to discount factor , where 0 1:",
               "We can interpret in several ways. It can be seen as an interest rate, a probability of living another step, or as a mathematical trick to bound the innnite sum. The model is conceptually similar to receding-horizon control, but the discounted model is more mathematically tractable than the model. This is a dominant reason for the wide attention this model has received.",
               "Another optimality criterion is the average-reward m o del, in which the agent is supposed to take actions that optimize its long-run average reward:",
               "Such a policy is referred to as a gain optimal policy; it can be seen as the limiting case of the innnite-horizon discounted model as the discount factor approaches 1 Bertsekas, 1995.",
               "One problem with this criterion is that there is no way to distinguish between two policies, one of which gains a large amount o f r e w ard in the initial phases and the other of which does not. Reward gained on any initial preex of the agent's life is overshadowed by the long-run average performance. It is possible to generalize this model so that it takes into account both the long run average and the amount of initial reward than can be gained.",
               "In the generalized, bias optimal model, a policy is preferred if it maximizes the long-run average and ties are broken by the initial extra reward. contrasts these models of optimality b y providing an environment in which changing the model of optimality c hanges the optimal policy. In this example, circles represent the states of the environment and arrows are state transitions. There is only a single action choice from every state except the start state, which is in the upper left and marked with an incoming arrow. All rewards are zero except where marked. Under a model with h = 5, the three actions yield rewards of +6:0, +0:0, and +0:0, so the action should be chosen; under an innnite-horizon discounted model with = 0 :9, the three choices yield +16:2, +59:0, and +58:5 so the second action should be chosen; and under the average reward model, the third action should be chosen since it leads to an average reward of +11. If we c hange h to 1000 and to 0.2, then the second action is optimal for the model and the for the innnite-horizon discounted model; however, the average reward model will always prefer the best long-term average. Since the choice of optimality model and parameters matters so much, it is important t o c hoose it carefully in any application.",
               "The model is appropriate when the agent's lifetime is known; one important aspect of this model is that as the length of the remaining lifetime decreases, the agent's policy may c hange. A system with a hard deadline would be appropriately modeled this way. The relative usefulness of innnite-horizon discounted and bias-optimal models is still under debate. Bias-optimality has the advantage of not requiring a discount parameter; however, algorithms for bias-optimal policies are not yet as well-understood as those for optimal innnite-horizon discounted policies."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 3,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "1.3",
               "text": "Measuring Learning Performance",
               "type": "modelling"
          },
          "paragraphs": [
               "The criteria given in the previous section can be used to assess the policies learned by a given algorithm. We w ould also like to be able to evaluate the quality of learning itself. There are several incompatible measures in use.",
               "Eventual convergence to optimal. Many algorithms come with a provable guarantee of asymptotic convergence to optimal behavior . This is reassuring, but useless in practical terms. An agent that quickly reaches a plateau at 99 of optimality m a y, in many applications, be preferable to an agent that has a guarantee of eventual optimality but a sluggish early learning rate.",
               "Speed of convergence to optimality. Optimality is usually an asymptotic result, and so convergence speed is an ill-deened measure. More practical is the speed o f convergence t o n e ar-optimality. This measure begs the deenition of how near to optimality is suucient. A related measure is level of performance after a given time, which similarly requires that someone deene the given time. It should be noted that here we h a ve another diierence between reinforcement learning and conventional supervised learning. In the latter, expected future predictive accuracy or statistical eeciency are the prime concerns. For example, in the well-known PAC framework Valiant, 1984, there is a learning period during which mistakes do not count, then a performance period during which they do. The framework provides bounds on the necessary length of the learning period in order to have a probabilistic guarantee on the subsequent performance. That is usually an inappropriate view for an agent with a long existence in a complex environment. In spite of the mismatch b e t ween embedded reinforcement learning and the trainntest perspective, Fiechter 1994 provides a PAC analysis for Q-learning described in Section 4.2 that sheds some light on the connection between the two views. Measures related to speed of learning have an additional weakness. An algorithm that merely tries to achieve optimality as fast as possible may incur unnecessarily large penalties during the learning period. A less aggressive strategy taking longer to achieve optimality, but gaining greater total reinforcement during its learning might be preferable.",
               "Regret. A more appropriate measure, then, is the expected decrease in reward gained due to executing the learning algorithm instead of behaving optimally from the very beginning. This measure is known as regret . It penalizes mistakes wherever they occur during the run. Unfortunately, results concerning the regret of algorithms are quite hard to obtain."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 4,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "1.4",
               "text": "Reinforcement Learning and Adaptive Control",
               "type": "modelling"
          },
          "paragraphs": [
               "Adaptive control is also concerned with algorithms for improving a sequence of decisions from experience. Adaptive control is a much more mature discipline that concerns itself with dynamic systems in which states and actions are vectors and system dynamics are smooth: linear or locally linearizable around a desired trajectory. A v ery common formulation of cost functions in adaptive control are quadratic penalties on deviation from desired state and action vectors. Most importantly, although the dynamic model of the system is not known in advance, and must be estimated from data, the structure of the dynamic model is leaving model estimation as a parameter estimation problem. These assumptions permit deep, elegant and powerful mathematical analysis, which in turn lead to robust, practical, and widely deployed adaptive control algorithms."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 5,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "2.",
               "text": "Exploitation versus Exploration: The Single-State Case",
               "type": "modelling"
          },
          "paragraphs": [
               "One major diierence between reinforcement learning and supervised learning is that a reinforcement-learner must explicitly explore its environment. In order to highlight the problems of exploration, we treat a very simple case in this section. The fundamental issues and approaches described here will, in many cases, transfer to the more complex instances of reinforcement learning discussed later in the paper.",
               "The simplest possible reinforcement-learning problem is known as the k-armed bandit problem, which has been the subject of a great deal of study in the statistics and applied mathematics literature . The agent is in a room with a collection of k gambling machines each called a bandit\" in colloquial English. The agent i s permitted a number of pulls, h. A n y arm may be pulled on each turn. The machines do not require a deposit to play; the only cost is in wasting a pull playing a suboptimal machine. When arm i is pulled, machine i pays oo 1 or 0, according to some underlying probability parameter p i , where payoos are independent e v ents and the p i s are unknown.",
               "What should the agent's strategy be?",
               "This problem illustrates the fundamental tradeoo between exploitation and exploration. The agent might believe that a particular arm has a fairly high payoo probability; should it choose that arm all the time, or should it choose another one that it has less information about, but seems to be worse? Answers to these questions depend on how long the agent is expected to play the game; the longer the game lasts, the worse the consequences of prematurely converging on a sub-optimal arm, and the more the agent should explore.",
               "There is a wide variety of solutions to this problem. We will consider a representative selection of them, but for a deeper discussion and a number of important theoretical results, see the book by Berry and Fristedt 1985. We use the term to indicate the agent's choice of arm to pull. This eases the transition into delayed reinforcement models in Section 3. It is very important to note that bandit problems our deenition of a reinforcement-learning environment with a single state with only self transitions.",
               "Section 2.1 discusses three solutions to the basic one-state bandit problem that have formal correctness results. Although they can be extended to problems with real-valued rewards, they do not apply directly to the general multi-state delayed-reinforcement case. Section 2.2 presents three techniques that are not formally justiied, but that have had wide use in practice, and can be applied with similar lack of guarantee to the general case."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 6,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "2.1",
               "text": "Formally Justiied Techniques",
               "type": "modelling"
          },
          "paragraphs": [
               "There is a fairly well-developed formal theory of exploration for very simple problems. Although it is instructive, the methods it provides do not scale well to more complex problems."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 7,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "2.1.1",
               "text": "Dynamic-Programming Approach",
               "type": "modelling"
          },
          "paragraphs": [
               "If the agent is going to be acting for a total of h steps, it can use basic Bayesian reasoning to solve for an optimal strategy . This requires an assumed prior joint distribution for the parameters fp i g, the most natural of which is that each p i is independently uniformly distributed between 0 and 1. We compute a mapping from belief states summaries of the agent's experiences during this run to actions. Here, a belief state can be represented as a tabulation of action choices and payoos: fn 1 ; w 1 ; n 2 ; w 2 ; : : : ; n k ; w k g denotes a state of play in which each arm i has been pulled n i times with w i payoos. We write V n 1 ; w 1 ; : : : ; n k ; w k as the expected payoo remaining, given that a total of h pulls are available, and we use the remaining pulls optimally. If P i n i = h, then there are no remaining pulls, and V n 1 ; w 1 ; : : : ; n k ; w k = 0. This is the basis of a recursive deenition. If we know the V value for all belief states with t pulls remaining, we can compute the V value of any belief state with t + 1 pulls remaining: V n 1 ; w 1 ; : : : ; n k ; w k = max i E \" Future payoo if agent takes action i, then acts optimally for remaining pulls ! = max i i V n 1 ; w i ; : : : ; n i + 1 ; w i + 1 ; : : : ; n k ; w k + 1 , i V n 1 ; w i ; : : : ; n i + 1 ; w i ; : : : ; n k ; w k where i is the posterior subjective probability of action i paying oo given n i , w i and our prior probability. For the uniform priors, which result in a beta distribution, i = w i + 1 =n i + 2.",
               "The expense of in the table of V values in this way for all attainable belief states is linear in the number of belief states times actions, and thus exponential in the horizon."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 8,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "2.1.2",
               "text": "Gittins Allocation Indices",
               "type": "modelling"
          },
          "paragraphs": [
               "Gittins gives an index\" method for the optimal choice of action at each step in k-armed bandit problems  Because of the guarantee of optimal exploration and the simplicity of the technique given the table of index values, this approach holds a great deal of promise for use in more complex applications. This method proved useful in an application to robotic manipulation with immediate reward . Unfortunately, no one has yet been able to an analog of index values for delayed reinforcement problems."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 9,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "2.1.3",
               "text": "Learning Automata",
               "type": "modelling"
          },
          "paragraphs": [
               "A branch of the theory of adaptive control is devoted to learning automata, surveyed by Narendra and Thathachar 1989, which w ere originally described explicitly as state automata. The Tsetlin automaton shown in provides an example that solves a 2-armed bandit arbitrarily near optimally as N approaches innnity.",
               "It is inconvenient to describe algorithms as automata, so a move w as made to describe the internal state of the agent as a probability distribution according to which actions would be chosen. The probabilities of taking diierent actions would be adjusted according to their previous successes and failures.",
               "An example, which stands among a set of algorithms independently developed in the mathematical psychology literature , is the linear reward-inaction algorithm. Let p i be the agent's probability of taking action i.",
               "When action a i succeeds, p i := p i + 1 , p i p j := p j , p j for j 6 = i When action a i fails, p j remains unchanged for all j.",
               "This algorithm converges with probability 1 t o a v ector containing a single 1 and the rest 0's choosing a particular action with probability 1. Unfortunately, it does not always converge to the correct action; but the probability that it converges to the wrong one can be made arbitrarily small by making small . There is no literature on the regret of this algorithm."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 10,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "2.2",
               "text": "Ad-Hoc Techniques",
               "type": "modelling"
          },
          "paragraphs": [
               "In reinforcement-learning practice, some simple, ad hoc strategies have been popular. They are rarely, i f e v er, the best choice for the models of optimality w e h a ve used, but they may be viewed as reasonable, computationally tractable, heuristics. Thrun 1992 has surveyed a v ariety of these techniques."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 11,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "2.2.1",
               "text": "Greedy Strategies",
               "type": "modelling"
          },
          "paragraphs": [
               "The strategy that comes to mind is to always choose the action with the highest estimated payoo. The is that early unlucky sampling might indicate that the best action's reward is less than the reward obtained from a suboptimal action. The suboptimal action will always be picked, leaving the true optimal action starved of data and its superiority never discovered. An agent m ust explore to ameliorate this outcome.",
               "A useful heuristic is optimism in the face of uncertainty in which actions are selected greedily, but strongly optimistic prior beliefs are put on their payoos so that strong negative evidence is needed to eliminate an action from consideration. This still has a measurable danger of starving an optimal but unlucky action, but the risk of this can be made arbitrarily small. Techniques like this have been used in several reinforcement learning algorithms including the interval exploration method Kaelbling, 1993b described shortly, the exploration bonus in Dyna Sutton, 1990, curiosity-driven exploration , and the exploration mechanism in prioritized sweeping Moore & Atkeson, 1993."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 12,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "2.2.2",
               "text": "Randomized Strategies",
               "type": "modelling"
          },
          "paragraphs": [
               "Another simple exploration strategy is to take the action with the best estimated expected reward by default, but with probability p, c hoose an action at random. Some versions of this strategy start with a large value of p to encourage initial exploration, which is slowly decreased.",
               "An objection to the simple strategy is that when it experiments with a non-greedy action it is no more likely to try a promising alternative than a clearly hopeless alternative. A slightly more sophisticated strategy is In this case, the expected reward for taking action a, ERa is used to choose an action probabilistically according to",
               "The temperature parameter T can be decreased over time to decrease exploration. This method works well if the best action is well separated from the others, but suuers somewhat when the values of the actions are close. It may also converge unnecessarily slowly unless the temperature schedule is manually tuned with great care."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 13,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "2.2.3",
               "text": "Interval-based Techniques",
               "type": "modelling"
          },
          "paragraphs": [
               "Exploration is often more eecient when it is based on second-order information about the certainty o r v ariance of the estimated values of actions. Kaelbling's interval estimation algorithm 1993b stores statistics for each action a i : w i is the number of successes and n i the number of trials. An action is chosen by computing the upper bound of a 100 1, conndence interval on the success probability of each action and choosing the action with the highest upper bound. Smaller values of the parameter encourage greater exploration.",
               "When payoos are boolean, the normal approximation to the binomial distribution can be used to construct the conndence interval though the binomial should be used for small n. Other payoo distributions can be handled using their associated statistics or with nonparametric methods. The method works very well in empirical trials. It is also related to a certain class of statistical techniques known as experiment design methods , which are used for comparing multiple treatments for example, fertilizers or drugs to determine which treatment if any is best in as small a set of experiments as possible."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 14,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "2.3",
               "text": "More General Problems",
               "type": "modelling"
          },
          "paragraphs": [
               "When there are multiple states, but reinforcement is still immediate, then any of the above solutions can be replicated, once for each state. However, when generalization is required, these solutions must be integrated with generalization methods see section 6; this is straightforward for the simple ad-hoc methods, but it is not understood how to maintain theoretical guarantees.",
               "Many of these techniques focus on converging to some regime in which exploratory actions are taken rarely or never; this is appropriate when the environment is stationary. However, when the environment is non-stationary, exploration must continue to take place, in order to notice changes in the world. Again, the more ad-hoc techniques can be modiied to deal with this in a plausible manner keep temperature parameters from going to 0; decay the statistics in interval estimation, but none of the theoretically guaranteed methods can be applied."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 15,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "3.",
               "text": "Delayed Reward",
               "type": "modelling"
          },
          "paragraphs": [
               "In the general case of the reinforcement learning problem, the agent's actions determine not only its immediate reward, but also at least probabilistically the next state of the environment. Such e n vironments can be thought o f a s n e t works of bandit problems, but the agent m ust take i n to account the next state as well as the immediate reward when it decides which action to take. The model of long-run optimality the agent is using determines exactly how it should take the value of the future into account. The agent will have t o b e able to learn from delayed reinforcement: it may take a long sequence of actions, receiving insigniicant reinforcement, then arrive at a state with high reinforcement. The agent must be able to learn which of its actions are desirable based on reward that can take place arbitrarily far in the future."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 16,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "3.1",
               "text": "Markov Decision Processes",
               "type": "modelling"
          },
          "paragraphs": [
               "Problems with delayed reinforcement are well modeled as Markov decision processes MDPs. An MDP consists of a set of states S, a set of actions A, a reward function R : S A ! ! , and a state transition function T : S A!S, where a memb e r o f S is a probability distribution over the set S i.e. it maps states to probabilities. We write Ts; a; s 0 for the probability of making a transition from state s to state s 0 using action a.",
               "The state transition function probabilistically speciies the next state of the environment a s a function of its current state and the agent's action. The reward function speciies expected instantaneous reward as a function of the current state and action. The model is Markov if the state transitions are independent o f a n y previous environment states or agent actions. There are many good references to .",
               "Although general MDPs m a y h a ve innnite even uncountable state and action spaces, we will only discuss methods for solving and problems. In section 6, we discuss methods for solving problems with continuous input and output spaces."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 17,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "3.2",
               "text": "Finding a Policy Given a Model",
               "type": "modelling"
          },
          "paragraphs": [
               "Before we consider algorithms for learning to behave i n MDP environments, we will explore techniques for determining the optimal policy given a correct model. These dynamic programming techniques will serve as the foundation and inspiration for the learning algorithms to follow. We restrict our attention mainly to optimal policies for the innnite-horizon discounted model, but most of these algorithms have analogs for the horizon and average-case models as well. We rely on the result that, for the innnite-horizon discounted model, there exists an optimal deterministic stationary policy Bellman, 1957.",
               "We will speak of the optimal value of a state|it is the expected innnite discounted sum of reward that the agent will gain if it starts in that state and executes the optimal policy.",
               "Using as a complete decision policy, it is written ! It is not obvious when to stop the value iteration algorithm. One important result bounds the performance of the current greedy policy as a function of the Bellman residual of the current v alue function . It says that if the maximum diierence between two successive v alue functions is less than , then the value of the greedy policy, the policy obtained by c hoosing, in every state, the action that maximizes the estimated discounted reward, using the current estimate of the value function diiers from the value function of the optimal policy by no more than 2 , a t a n y state. This provides an eeective stopping criterion for the algorithm. Puterman 1994 discusses another stopping criterion, based on the span semi-norm, which m a y result in earlier termination. Another important result is that the greedy policy is guaranteed to be optimal in some number of steps even though the value function may not have converged . And in practice, the greedy policy is often optimal long before the value function has converged.",
               "Value iteration is very The assignments to V need not be done in strict order as shown above, but instead can occur asynchronously in parallel provided that the value of every state gets updated innnitely often on an innnite run. These issues are treated extensively by Bertsekas 1989, who also proves convergence results.",
               "Updates based on Equation 1 are known as full backups since they make use of information from all possible successor states. It can be shown that updates of the form Qs; a : = Qs; a + r + max a 0 Qs 0 ; a 0 , Qs; a can also be used as long as each pairing of a and s is updated innnitely often, s 0 is sampled from the distribution Ts; a; s 0 , r is sampled with mean Rs; a and bounded variance, and the learning rate is decreased slowly. This type of sample backup Singh, 1993 is critical to the operation of the model-free methods discussed in the next section.",
               "The computational complexity of the value-iteration algorithm with full backups, per iteration, is quadratic in the number of states and linear in the number of actions. Commonly, the transition probabilities Ts; a; s 0 are sparse. If there are on average a constant number of next states with non-zero probability then the cost per iteration is linear in the number of states and linear in the number of actions. The number of iterations required to reach the optimal value function is polynomial in the number of states and the magnitude of the largest reward if the discount factor is held constant. However, in the worst case the number of iterations grows polynomially in 1=1 , , so the convergence rate slows considerably as the discount factor approaches 1 Littman, Dean, & Kaelbling, 1995b."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 18,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "3.2.2",
               "text": "Policy Iteration",
               "type": "modelling"
          },
          "paragraphs": [
               "The policy iteration algorithm manipulates the policy directly, rather than it indirectly via the optimal value function. It operates as follows: The value function of a policy is just the expected innnite discounted reward that will be gained, at each state, by executing that policy. It can be determined by solving a set of linear equations. Once we know the value of each state under the current policy, w e consider whether the value could be improved by c hanging the action taken. If it can, we c hange the policy to take the new action whenever it is in that situation. This step is guaranteed to strictly improve the performance of the policy. When no improvements are possible, then the policy is guaranteed to be optimal.",
               "Since there are at most jAj jSj distinct policies, and the sequence of policies improves at each step, this algorithm terminates in at most an exponential number of iterations Puterman, 1994. However, it is an important open question how many iterations policy iteration takes in the worst case. It is known that the running time is pseudopolynomial and that for any discount factor, there is a polynomial bound in the total size of the MDP Littman et al., 1995b."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 19,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "3.2.3",
               "text": "Enhancement to Value Iteration and Policy Iteration",
               "type": "modelling"
          },
          "paragraphs": [
               "In practice, value iteration is much faster per iteration, but policy iteration takes fewer iterations. Arguments have been put forth to the eeect that each approach is better for large problems. Puterman's modiied p olicy iteration algorithm provides a method for trading iteration time for iteration improvement in a smoother way. The basic idea is that the expensive part of policy iteration is solving for the exact value of V . Instead of an exact value for V , w e can perform a few steps of a modiied value-iteration step where the policy is held over successive iterations. This can be shown to produce an approximation to V that converges linearly in . In practice, this can result in substantial speedups.",
               "Several standard numerical-analysis techniques that speed the convergence of dynamic programming can be used to accelerate value and policy iteration. Multigrid methods can be used to quickly seed a good initial approximation to a high resolution value function by initially performing value iteration at a coarser resolution R ude, 1993. State aggregation works by collapsing groups of states to a single meta-state solving the abstracted problem "
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 20,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "3.2.4",
               "text": "Computational Complexity",
               "type": "modelling"
          },
          "paragraphs": [
               "Value iteration works by producing successive approximations of the optimal value function.",
               "Each iteration can be performed in OjAjjSj 2 steps, or faster if there is sparsity in the transition function. However, the number of iterations required can grow exponentially in the discount factor Condon, 1992; as the discount factor approaches 1, the decisions must be based on results that happen farther and farther into the future. In practice, policy iteration converges in fewer iterations than value iteration, although the per-iteration costs of OjAjjSj 2 + jSj 3 can be prohibitive. There is no known tight w orst-case bound available for policy iteration . Modiied policy iteration seeks a trade-oo between cheap and eeective iterations and is preferred by some practictioners Rust, 1996.",
               "Linear programming Schrijver, 1986 is an extremely general problem, and MDPs can be solved by general-purpose linear-programming packages . An advantage of this approach is that commercial-quality linear-programming packages are available, although the time and space requirements can still be quite high. From a theoretic perspective, linear programming is the only known algorithm that can solve MDPs in polynomial time, although the theoretically eecient algorithms have not been shown to be eecient in practice."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 21,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "4.",
               "text": "Learning an Optimal Policy: Model-free Methods",
               "type": "modelling"
          },
          "paragraphs": [
               "In the previous section we reviewed methods for obtaining an optimal policy for an MDP assuming that we already had a model. The model consists of knowledge of the state transition probability function Ts; a; s 0 and the reinforcement function Rs; a. Reinforcement learning is primarily concerned with how to obtain the optimal policy when such a model is not known in advance. The agent m ust interact with its environment directly to obtain information which, by means of an appropriate algorithm, can be processed to produce an optimal policy.",
               "At this point, there are two w ays to proceed.",
               "Model-free: Learn a controller without learning a model. Model-based: Learn a model, and use it to derive a controller.",
               "Which approach is better? This is a matter of some debate in the reinforcement-learning community. A n umber of algorithms have been proposed on both sides. This question also appears in other such as adaptive control, where the dichotomy i s b e t ween direct and indirect adaptive control. This section examines model-free learning, and Section 5 examines model-based methods.",
               "The biggest problem facing a reinforcement-learning agent i s temporal credit assignment. How d o w e know whether the action just taken is a good one, when it might h a ve farreaching eeects? One strategy is to wait until the and reward the actions taken if the result was good and punish them if the result was bad. In ongoing tasks, it is diicult to know what the is, and this might require a great deal of memory. Instead, we will use insights from value iteration to adjust the estimated value of a state based on the immediate reward and the estimated value of the next state. This class of algorithms is known as temporal diierence methods Sutton, 1988. We will consider two diierent temporal-diierence learning strategies for the discounted innnite-horizon model."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 22,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "4.1",
               "text": "Adaptive Heuristic Critic and TD",
               "type": "modelling"
          },
          "paragraphs": [
               "The adaptive heuristic critic algorithm is an adaptive v ersion of policy iteration in which the value-function computation is no longer implemented by solving a set of linear equations, but is instead computed by an algorithm called TD 0. A block diagram for this approach is given in . It consists of two components: a critic labeled AHC, and a reinforcement-learning component labeled RL. The reinforcement-learning component can be an instance of any o f t h e k-armed bandit algorithms, modiied to deal with multiple states and non-stationary rewards. But instead of acting to maximize instantaneous reward, it will be acting to maximize the heuristic value, v, that is computed by the critic. The critic uses the real external reinforcement signal to learn to map states to their expected discounted values given that the policy being executed is the one currently instantiated in the RL component.",
               "We can see the analogy with modiied policy iteration if we imagine these components working in alternation. Whenever a state s is visited, its estimated value is updated to be closer to r + Vs 0 , since r is the instantaneous reward received and V s 0 is the estimated value of the actually occurring next state. This is analogous to the sample-backup rule from value iteration|the only diierence is that the sample is drawn from the real world rather than by simulating a known model. The key idea is that r + Vs 0 is a sample of the value of V s, and it is more likely to be correct because it incorporates the real r. If the learning rate is adjusted properly it must be slowly decreased and the policy is held TD 0 is guaranteed to converge to the optimal value function.",
               "The TD 0 rule as presented above is really an instance of a more general class of algorithms called TD , with = 0 . TD 0 looks only one step ahead when adjusting value estimates; although it will eventually arrive at the correct answer, it can take quite a while to do so. The general TD rule is similar to the TD 0 rule given above, The eligibility of a state s is the degree to which it has been visited in the recent past; when a reinforcement is received, it is used to update all the states that have been recently visited, according to their eligibility. When = 0 this is equivalent t o TD 0. When = 1 , it is roughly equivalent to updating all the states according to the number of times they were visited by the end of a run. Note that we can update the eligibility online as follows:",
               "It is computationally more expensive to execute the general TD , though it often converges considerably faster for large . There has been some recent w ork on making the updates more eecient and on changing the deenition to make TD more consistent with the certainty-equivalent method , which is discussed in Section 5.1."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 23,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "4.2",
               "text": "Q-learning",
               "type": "modelling"
          },
          "paragraphs": [
               "The work of the two components of AHC can be accomplished in a uniied manner by Watkins' Q-learning algorithm Because the Q function makes the action explicit, we can estimate the Q values online using a method essentially the same as TD 0, but also use them to deene the policy, because an action can be chosen just by taking the one with the maximum Q value for the current state.",
               "The Q-learning rule is",
               "Qs; a : = Qs; a + r + max a 0 Qs 0 ; a 0 , Qs; a ; where hs; a; r; s 0 i is an experience tuple as described earlier. If each action is executed in each state an innnite number of times on an innnite run and is decayed appropriately, the Q values will converge with probability 1 t o Q . Q-learning can also be extended to update states that occurred more than one step previously, a s i n TD P eng & Williams, 1994.",
               "When the Q values are nearly converged to their optimal values, it is appropriate for the agent to act greedily, taking, in each situation, the action with the highest Q value.",
               "During learning, however, there is a diicult exploitation versus exploration trade-oo to be made. There are no good, formally justiied approaches to this problem in the general case; standard practice is to adopt one of the ad hoc methods discussed in section 2.2.",
               "AHC architectures seem to be more diicult to work with than Q-learning on a practical level. It can be hard to get the relative learning rates right in AHC so that the two components converge together. In addition, Q-learning is exploration insensitive: that is, that the Q values will converge to the optimal values, independent o f h o w the agent behaves while the data is being collected as long as all state-action pairs are tried often enough. This means that, although the exploration-exploitation issue must be addressed in Q-learning, the details of the exploration strategy will not aaect the convergence of the learning algorithm. For these reasons, Q-learning is the most popular and seems to be the most eeective model-free algorithm for learning from delayed reinforcement. It does not, however, address any of the issues involved in generalizing over large state anddor action spaces. In addition, it may converge quite slowly to a good policy."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 24,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "4.3",
               "text": "Model-free Learning With Average Reward",
               "type": "modelling"
          },
          "paragraphs": [
               "As described, Q-learning can be applied to discounted innnite-horizon MDPs. It can also be applied to undiscounted problems as long as the optimal policy is guaranteed to reach a reward-free absorbing state and the state is periodically reset.",
               "Schwartz 1993 examined the problem of adapting Q-learning to an average-reward framework. Although his R-learning algorithm seems to exhibit convergence problems for some MDPs, several researchers have found the average-reward criterion closer to the true problem they wish to solve than a discounted criterion and therefore prefer R-learning to Q-learning With that in mind, researchers have studied the problem of learning optimal averagereward policies. Mahadevan 1996 surveyed model-based average-reward algorithms from a reinforcement-learning perspective and found several diiculties with existing algorithms. In particular, he showed that existing reinforcement-learning algorithms for average reward and some dynamic programming algorithms do not always produce bias-optimal policies. Jaakkola, Jordan and Singh 1995 described an average-reward learning algorithm with guaranteed convergence properties. It uses a Monte-Carlo component to estimate the expected future reward for each state as the agent m o ves through the environment. In addition, Bertsekas presents a Q-learning-like algorithm for average-case reward in his new textbook 1995. Although this recent w ork provides a much needed theoretical foundation to this area of reinforcement learning, many important problems remain unsolved."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 25,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "5.",
               "text": "Computing Optimal Policies by Learning Models",
               "type": "modelling"
          },
          "paragraphs": [
               "The previous section showed how it is possible to learn an optimal policy without knowing the models Ts; a; s 0 o r Rs; a and without even learning those models en route. Although many of these methods are guaranteed to optimal policies eventually and use very little computation time per experience, they make extremely ineecient use of the data they gather and therefore often require a great deal of experience to achieve good performance. In this section we still begin by assuming that we don't know the models in advance, but we examine algorithms that do operate by learning these models. These algorithms are especially important in applications in which computation is considered to be cheap and real-world experience costly."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 26,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "5.1",
               "text": "Certainty Equivalent Methods",
               "type": "modelling"
          },
          "paragraphs": [
               "We begin with the most conceptually straightforward method: learn the T and R functions by exploring the environment and keeping statistics about the results of each action; next, compute an optimal policy using one of the methods of Section 3. This method is known as certainty equivlance There are some serious objections to this method:",
               "It makes an arbitrary division between the learning phase and the acting phase. How should it gather data about the environment initially? Random exploration might be dangerous, and in some environments is an immensely ineecient method of gathering data, requiring exponentially more data Whitehead, 1991 than a system that interleaves experience gathering with policy-building more tightly . See for an example.",
               "The possibility o f c hanges in the environment is also problematic. Breaking up an agent's life into a pure learning and a pure acting phase has a considerable risk that the optimal controller based on early life becomes, without detection, a suboptimal controller if the environment c hanges. A v ariation on this idea is certainty equivalence, in which the model is learned continually through the agent's lifetime and, at each step, the current model is used to compute an optimal policy and value function. This method makes very eeective use of available data, but still ignores the question of exploration and is extremely computationally demanding, even for fairly small state spaces. Fortunately, there are a number of other model-based algorithms that are more practical."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 27,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "5.2",
               "text": "Dyna",
               "type": "modelling"
          },
          "paragraphs": [
               "Sutton's Dyna architecture 1990, 1991 exploits a middle ground, yielding strategies that are both more eeective than model-free learning and more computationally eecient than Choose an action a 0 to perform in state s 0 , based on the Q values but perhaps modiied by an exploration strategy.",
               "The Dyna algorithm requires about k times the computation of Q-learning per instance, but this is typically vastly less than for the naive model-based method. A reasonable value of k can be determined based on the relative speeds of computation and of taking action. shows a grid world in which in each cell the agent has four actions N, S, E, W and transitions are made deterministically to an adjacent cell, unless there is a block, in which case no movement occurs. As we will see in , Dyna requires an order of magnitude fewer steps of experience than does Q-learning to arrive at an optimal policy. Dyna requires about six times more computational eeort, however. Steps before Backups before convergence convergence Q-learning 531,000 531,000 Dyna 62,000 3,055,000 prioritized sweeping 28,000 1,010,000 : The performance of three algorithms described in the text. All methods used the exploration heuristic of in the face of uncertainty\": any state not previously visited was assumed by default to be a goal state. Q-learning used its optimal learning rate parameter for a deterministic maze: = 1. Dyna and prioritized sweeping were permitted to take k = 200 backups per transition. For prioritized sweeping, the priority queue often emptied before all backups were used."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 28,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "5.3",
               "text": "Prioritized Sweeping Queue-Dyna",
               "type": "modelling"
          },
          "paragraphs": [
               "Although Dyna is a great improvement on previous methods, it suuers from being relatively undirected. It is particularly unhelpful when the goal has just been reached or when the agent is stuck in a dead end; it continues to update random state-action pairs, rather than concentrating on the parts of the state space. These problems are addressed by prioritized sweeping , which are two independently-developed but very similar techniques. We will describe prioritized sweeping in some detail. The algorithm is similar to Dyna, except that updates are no longer chosen at random and values are now associated with states as in value iteration instead of state-action pairs as in Q-learning. To make appropriate choices, we m ust store additional information in the model. Each state remembers its predecessors: the states that have a non-zero transition probability to it under some action. In addition, each state has a priority, initially set to zero.",
               "Instead of updating k random state-action pairs, prioritized sweeping updates k states with the highest priority. F or each high-priority state s, i t w orks as follows:",
               "Remember the current v alue of the state: V old = V s. Compute the value change = jV old , V sj.",
               "Use to modify the priorities of the predecessors of s.",
               "If we h a ve updated the V value for state s 0 and it has changed by amount , then the immediate predecessors of s 0 are informed of this event. Any state s for which there exists an action a such that ^ Ts; a; s 0 6 = 0 has its priority promoted to ^ Ts; a; s 0 , unless its priority already exceeded that value.",
               "The global behavior of this algorithm is that when a real-world transition is the agent happens upon a goal state, for instance, then lots of computation is directed to propagate this new information back to relevant predecessor states. When the realworld transition is the actual result is very similar to the predicted result, then computation continues in the most deserving part of the space.",
               "Running prioritized sweeping on the problem in , we see a large improvement over Dyna. The optimal policy is reached in about half the number of steps of experience and one-third the computation as Dyna required and therefore about 20 times fewer steps and twice the computational eeort of Q-learning."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 29,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "5.4",
               "text": "Other Model-Based Methods",
               "type": "modelling"
          },
          "paragraphs": [
               "Methods proposed for solving MDPs given a model can be used in the context of modelbased methods as well.",
               "RTDP real-time dynamic programming Barto, Bradtke, & Singh, 1995 is another model-based method that uses Q-learning to concentrate computational eeort on the areas of the state-space that the agent is most likely to occupy. It is speciic to problems in which the agent is trying to achieve a particular goal state and the reward everywhere else is 0. By taking into account the start state, it can a short path from the start to the goal, without necessarily visiting the rest of the state space.",
               "The Plexus planning system Dean, exploits a similar intuition. It starts by making an approximate version of the MDP which i s m uch smaller than the original one. The approximate MDP contains a set of states, called the envelope, that includes the agent's current state and the goal state, if there is one. States that are not in the envelope are summarized by a single state. The planning process is an alternation between an optimal policy on the approximate MDP and adding useful states to the envelope. Action may take place in parallel with planning, in which case irrelevant states are also pruned out of the envelope."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 30,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "6.",
               "text": "Generalization",
               "type": "modelling"
          },
          "paragraphs": [
               "All of the previous discussion has tacitly assumed that it is possible to enumerate the state and action spaces and store tables of values over them. Except in very small environments, this means impractical memory requirements. It also makes ineecient use of experience. In a large, smooth state space we generally expect similar states to have similar values and similar optimal actions. Surely, therefore, there should be some more compact representation than a table. Most problems will have continuous or large discrete state spaces; some will have large or continuous action spaces. The problem of learning in large spaces is addressed through generalization techniques, which allow compact storage of learned information and transfer of knowledge between states and actions.",
               "The large literature of generalization techniques from inductive concept learning can be applied to reinforcement learning. However, techniques often need to be tailored to speciic details of the problem. In the following sections, we explore the application of standard function-approximation techniques, adaptive resolution models, and hierarchical methods to the problem of reinforcement learning.",
               "The reinforcement-learning architectures and algorithms discussed above h a ve included the storage of a variety of mappings, including S ! A policies, S ! value functions, S A ! ! Q functions and rewards, S A ! S deterministic transitions, and S A S ! 0; 11 transition probabilities. Some of these mappings, such as transitions and immediate rewards, can be learned using straightforward supervised learning, and can be handled using any of the wide variety of function-approximation techniques for supervised learning that support noisy training examples. Popular techniques include various neuralnetwork methods , and local memory-based methods Moore, Atkeson, & Schaal, 1995, such as generalizations of nearest neighbor methods. Other mappings, especially the policy mapping, typically need specialized algorithms because training sets of input-output pairs are not available."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 31,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "6.1",
               "text": "Generalization over Input",
               "type": "modelling"
          },
          "paragraphs": [
               "A reinforcement-learning agent's current state plays a central role in its selection of rewardmaximizing actions. Viewing the agent as a state-free black b o x, a description of the current state is its input. Depending on the agent architecture, its output is either an action selection, or an evaluation of the current state that can be used to select an action. The problem of deciding how the diierent aspects of an input aaect the value of the output is sometimes called the credit-assignment\" problem. This section examines approaches to generating actions or evaluations as a function of a description of the agent's current state. The group of techniques covered here is specialized to the case when reward is not delayed; the second group is more generally applicable."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 32,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "6.1.1",
               "text": "Immediate Reward",
               "type": "modelling"
          },
          "paragraphs": [
               "When the agent's actions do not innuence state transitions, the resulting problem becomes one of choosing actions to maximize immediate reward as a function of the agent's current state. These problems bear a resemblance to the bandit problems discussed in Section 2 except that the agent should condition its action selection on the current state. For this reason, this class of problems has been described as associative reinforcement learning.",
               "The algorithms in this section address the problem of learning from immediate boolean reinforcement where the state is vector valued and the action is a boolean vector. Such algorithms can and have been used in the context of a delayed reinforcement, for instance, as the RL component in the AHC architecture described in Section 4.1. They can also be generalized to real-valued reward through reward c omparison methods CRBP The complementary reinforcement backpropagation algorithm crbp consists of a feed-forward network mapping an encoding of the state to an encoding of the action. The action is determined probabilistically from the activation of the output units: if output unit i has activation y i , then bit i of the action vector has value 1 with probability y i , and 0 otherwise. Any neural-network supervised training procedure can be used to adapt the network as follows. If the result of generating action a is r = 1 , then the network is trained with input-output pair hs; ai. If the result is r = 0, then the network is trained with input-output pair hs; ai, where a = 1 , a 1 ; : : : ; 1 , a n .",
               "The idea behind this training rule is that whenever an action fails to generate reward, crbp will try to generate an action that is diierent from the current c hoice. Although it seems like the algorithm might oscillate between an action and its complement, that does not happen. One step of training a network will only change the action slightly and since the output probabilities will tend to move t o ward 0.5, this makes action selection more random and increases search. The hope is that the random distribution will generate an action that works better, and then that action will be reinforced.",
               "ARC The associative reinforcement comparison arc algorithm is an instance of the ahc architecture for the case of boolean actions, consisting of two feed-forward networks. One learns the value of situations, the other learns a policy. These can be simple linear networks or can have hidden units.",
               "In the simplest case, the entire system learns only to optimize immediate reward. First, let us consider the behavior of the network that learns the policy, a mapping from a vector describing s t o a 0 o r 1 . I f t h e output unit has activation y i , then a, the action generated, will be 1 if y + 0, where is normal noise, and 0 otherwise.",
               "The adjustment for the output unit is, in the simplest case, e = ra , 1=2 ;",
               "where the factor is the reward received for taking the most recent action and the second encodes which action was taken. The actions are encoded as 0 and 1, so a ,1=2 always has the same magnitude; if the reward and the action have the same sign, then action 1 will be made more likely, otherwise action 0 will be.",
               "As described, the network will tend to seek actions that given positive reward. To extend this approach to maximize reward, we can compare the reward to some baseline, b. This changes the adjustment t o e = r , ba , 1=2 ;",
               "where b is the output of the second network. The second network is trained in a standard supervised mode to estimate r as a function of the input state s.",
               "Variations of this approach h a ve been used in a variety of applications REINFORCE Algorithms studied the problem of choosing actions to maximize immedate reward. He identiied a broad class of update rules that perform gradient descent on the expected reward and showed how t o i n tegrate these rules with backpropagation. This class, called reinforce algorithms, includes linear reward-inaction Section 2.1.3 as a special case.",
               "The generic reinforce update for a parameter w ij can be written",
               "where ij is a non-negative factor, r the current reinforcement, b ij a reinforcement baseline, and g i is the probability density function used to randomly generate actions based on unit activations. Both ij and b ij can take on diierent v alues for each w ij , h o wever, when ij is constant throughout the system, the expected update is exactly in the direction of the expected reward gradient. Otherwise, the update is in the same half space as the gradient but not necessarily in the direction of steepest increase.",
               "Williams points out that the choice of baseline, b ij , can have a profound eeect on the convergence speed of the algorithm.",
               "Logic-Based Methods Another strategy for generalization in reinforcement learning is to reduce the learning problem to an associative problem of learning boolean functions. A boolean function has a vector of boolean inputs and a single boolean output. Taking inspiration from mainstream machine learning work, Kaelbling developed two algorithms for learning boolean functions from reinforcement: one uses the bias of k-DNF to drive the generalization process ; the other searches the space of syntactic descriptions of functions using a simple generate-and-test method .",
               "The restriction to a single boolean output makes these techniques diicult to apply. I n very benign learning situations, it is possible to extend this approach to use a collection of learners to independently learn the individual bits that make up a complex output. In general, however, that approach suuers from the problem of very unreliable reinforcement: if a single learner generates an inappropriate output bit, all of the learners receive a l o w reinforcement v alue. The cascade method Kaelbling, 1993b allows a collection of learners to be trained collectively to generate appropriate joint outputs; it is considerably more reliable, but can require additional computational eeort."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 33,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "6.1.2",
               "text": "Delayed Reward",
               "type": "modelling"
          },
          "paragraphs": [
               "Another method to allow reinforcement-learning techniques to be applied in large state spaces is modeled on value iteration and Q-learning. Here, a function approximator is used to represent the value function by mapping a state description to a value.",
               "Many reseachers have experimented with this approach: Boyan and Moore 1995 used local memory-based methods in conjunction with value iteration; Lin 1991 used backpropagation networks for Q-learning; Watkins 1989 used CMAC for Q-learning; used backpropagation for learning the value function in backgammon described in Section 8.1; Zhang and Dietterich 1995 used backpropagation and TD to learn good strategies for job-shop scheduling.",
               "Although there have been some positive examples, in general there are unfortunate interactions between function approximation and the learning rules. In discrete environments there is a guarantee that any operation that updates the value function according to the Bellman equations can only reduce the error between the current v alue function and the optimal value function. This guarantee no longer holds when generalization is used. These issues are discussed by B o yan and Moore 1995, who give some simple examples of value function errors growing arbitrarily large when generalization is used with value iteration. Their solution to this, applicable only to certain classes of problems, discourages such divergence by only permitting updates whose estimated values can be shown to be near-optimal via a battery of Monte-Carlo experiments.",
               "Thrun and Schwartz 1993 theorize that function approximation of value functions is also dangerous because the errors in value functions due to generalization can become compounded by the operator in the deenition of the value function.",
               "Several recent results show h o w the appropriate choice of function approximator can guarantee convergence, though not necessarily to the optimal values. Baird's residual gradient technique Baird, 1995 provides guaranteed convergence to locally optimal solutions.",
               "Perhaps the gloominess of these counter-examples is misplaced. Boyan and Moore 1995 report that their counter-examples can be made to work with problem-speciic hand-tuning despite the unreliability o f u n tuned algorithms that provably converge in discrete domains. Sutton 1996 shows how modiied versions of Boyan and Moore's examples can converge",
               "successfully. An open question is whether general principles, ideally supported by theory, can help us understand when value function approximation will succeed. In Sutton's com-parative experiments with Boyan and Moore's counter-examples, he changes four aspects of the experiments:",
               "1. Small changes to the task speciications. 2. A very diierent kind of function approximator that has weak generalization. 3. A diierent learning algorithm: SARSA Rummery & Niranjan, 1994 instead of value iteration. 4. A diierent training regime. Boyan and Moore sampled states uniformly in state space, whereas Sutton's method sampled along empirical trajectories. There are intuitive reasons to believe that the fourth factor is particularly important, but more careful research is needed.",
               "Adaptive Resolution Models In many cases, what we w ould like to do is partition the environment i n to regions of states that can be considered the same for the purposes of learning and generating actions. Without detailed prior knowledge of the environment, it is very diicult to know what granularity or placement of partitions is appropriate. This problem is overcome in methods that use adaptive resolution; during the course of learning, a partition is constructed that is appropriate to the environment.",
               "Decision Trees In environments that are characterized by a set of boolean or discretevalued variables, it is possible to learn compact decision trees for representing Q values. The G-learning algorithm , works as follows. It starts by assuming that no partitioning is necessary and tries to learn Q values for the entire environment a s if it were one state. In parallel with this process, it gathers statistics based on individual input bits; it asks the question whether there is some bit b in the state description such that the Q values for states in which b = 1 are signiicantly diierent from Q values for states in which b = 0. If such a bit is found, it is used to split the decision tree. Then, the process is repeated in each of the leaves. This method was able to learn very small representations of the Q function in the presence of an overwhelming number of irrelevant, noisy state attributes. It outperformed Q-learning with backpropagation in a simple videogame environment and was used by McCallum 1995 in conjunction with other techniques for dealing with partial observability to learn behaviors in a complex driving-simulator. It cannot, however, acquire partitions in which attributes are only signiicant in combination such as those needed to solve parity problems.",
               "Variable Resolution Dynamic Programming enables conventional dynamic programming to be performed in real-valued multivariate state-spaces where straightforward discretization would fall prey to the curse of dimensionality. A kd-tree similar to a decision tree is used to partition state space into coarse regions. The coarse regions are reened into detailed regions, but only in parts of the state space which are predicted to be important. This notion of importance is obtained by running trajectories\" through state space. This algorithm proved eeective o n a n umber of problems for which full high-resolution arrays would have been impractical. It has the disadvantage of requiring a guess at an initially valid trajectory through state-space. PartiGame Algorithm Moore's PartiGame algorithm Moore, 1994 is another solution to the problem of learning to achieve goal conngurations in deterministic high-dimensional continuous spaces by learning an adaptive-resolution model. It also divides the environment into cells; but in each cell, the actions available consist of aiming at the neighboring cells this aiming is accomplished by a local controller, which m ust be provided as part of the problem statement. The graph of cell transitions is solved for shortest paths in an online incremental manner, but a minimax criterion is used to detect when a group of cells is too coarse to prevent m o vement b e t ween obstacles or to avoid limit cycles. The ooending cells are split to higher resolution. Eventually, the environment is divided up just enough to choose appropriate actions for achieving the goal, but no unnecessary distinctions are made. An important feature is that, as well as reducing memory and computational requirements, it also structures exploration of state space in a multi-resolution manner. Given a failure, the agent will initially try something very diierent to rectify the failure, and only resort to small local changes when all the qualitatively diierent strategies have been exhausted. show s a t wo-dimensional continuous maze. shows the performance of a robot using the PartiGame algorithm during the very trial. shows the second trial, started from a slightly diierent position. This is a very fast algorithm, learning policies in spaces of up to nine dimensions in less than a minute. The restriction of the current implementation to deterministic environments limits its applicability, h o wever. McCallum 1995 suggests some related tree-structured methods."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 34,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "6.2",
               "text": "Generalization over Actions",
               "type": "modelling"
          },
          "paragraphs": [
               "The networks described in Section 6.1.1 generalize over state descriptions presented as inputs. They also produce outputs in a discrete, factored representation and thus could be seen as generalizing over actions as well.",
               "In cases such as this when actions are described combinatorially, it is important t o generalize over actions to avoid keeping separate statistics for the huge number of actions that can be chosen. In continuous action spaces, the need for generalization is even more pronounced.",
               "When estimating Q values using a neural network, it is possible to use either a distinct network for each action, or a network with a distinct output for each action. When the action space is continuous, neither approach is possible. An alternative strategy is to use a single network with both the state and action as input and Q value as the output. Training such a network is not conceptually diicult, but using the network to the optimal action can be a challenge. One method is to do a local gradient-ascent search on the action in order to one with high value has developed a reinforcement-learning unit for use in continuous action spaces. The unit generates actions with a normal distribution; it adjusts the mean and variance based on previous experience. When the chosen actions are not performing well, the variance is high, resulting in exploration of the range of choices. When an action performs well, the mean is moved in that direction and the variance decreased, resulting in a tendency to generate more action values near the successful one. This method was successfully employed to learn to control a robot arm with many continuous degrees of freedom."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 35,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "6.3",
               "text": "Hierarchical Methods",
               "type": "modelling"
          },
          "paragraphs": [
               "Another strategy for dealing with large state spaces is to treat them as a hierarchy o f learning problems. In many cases, hierarchical solutions introduce slight sub-optimality i n performance, but potentially gain a good deal of eeciency in execution time, learning time, and space.",
               "Hierarchical learners are commonly structured as gated b ehaviors, as shown in . There is a collection of behaviors that map environment states into low-level actions and a gating function that decides, based on the state of the environment, which behavior's actions should be switched through and actually executed. Maes and Brooks 1990 used a v ersion of this architecture in which the individual behaviors were a priori and the gating function was learned from reinforcement. Mahadevan and Connell 1991b used the dual approach: they the gating function, and supplied reinforcement functions for the individual behaviors, which w ere learned. both used this approach, training the behaviors and then training the gating function. Many of the other hierarchical learning methods can be cast in this framework."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 36,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "6.3.1",
               "text": "Feudal Q-learning",
               "type": "modelling"
          },
          "paragraphs": [
               "Feudal Q-learning involves a hierarchy of learning modules. In the simplest case, there is a high-level master and a low-level slave. The master receives reinforcement from the external environment. Its actions consist of commands that it can give to the low-level learner. When the master generates a particular command to the slave, it must reward the slave for taking actions that satisfy the command, even if they do not result in external reinforcement. The master, then, learns a mapping from states to commands. The slave learns a mapping from commands and states to external actions. The set of and their associated reinforcement functions are established in advance of the learning. This is really an instance of the general behaviors\" approach, in which the slave can execute any of the behaviors depending on its command. The reinforcement functions for the individual behaviors commands are given, but learning takes place simultaneously at both the high and low levels."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 37,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "6.3.2",
               "text": "Compositional Q-learning",
               "type": "modelling"
          },
          "paragraphs": [
               "Singh's compositional Q-learning 1992b, 1992a C-QL consists of a hierarchy based on the temporal sequencing of subgoals. The elemental tasks are behaviors that achieve some recognizable condition. The high-level goal of the system is to achieve some set of conditions in sequential order. The achievement of the conditions provides reinforcement for the elemental tasks, which are trained to achieve individual subgoals. Then, the gating function learns to switch the elemental tasks in order to achieve the appropriate high-level sequential goal. This method was used by Tham and Prager 1994 to learn to control a simulated multi-link robot arm."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 38,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "6.3.3",
               "text": "Hierarchical Distance to Goal",
               "type": "modelling"
          },
          "paragraphs": [
               "Especially if we consider reinforcement learning modules to be part of larger agent architectures, it is important to consider problems in which goals are dynamically input to the learner. Kaelbling's HDG algorithm 1993a uses a hierarchical approach to solving problems when goals of achievement the agent should get to a particular state as quickly as possible are given to an agent dynamically.",
               "The HDG algorithm works by analogy with navigation in a harbor. The environment is partitioned a priori, but more recent w ork Ashar, 1994 addresses the case of learning the partition into a set of regions whose centers are known as If the agent i s currently in the same region as the goal, then it uses low-level actions to move to the goal. If not, then high-level information is used to determine the next landmark on the shortest path from the agent's closest landmark to the goal's closest landmark. Then, the agent uses low-level information to aim toward that next landmark. If errors in action cause deviations in the path, there is no problem; the best aiming point is recomputed on every step."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 39,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "7.",
               "text": "Partially Observable Environments",
               "type": "modelling"
          },
          "paragraphs": [
               "In many real-world environments, it will not be possible for the agent t o h a ve perfect and complete perception of the state of the environment. Unfortunately, complete observability is necessary for learning methods based on In this section, we consider the case in which the agent makes observations of the state of the environment, but these observations may be noisy and provide incomplete information. In the case of a robot, for instance, it might observe whether it is in a corridor, an open room, a T-junction, etc., and those observations might be error-prone. This problem is also referred to as the problem of perception,\" aliasing,\" or state.\" In this section, we will consider extensions to the basic MDP framework for solving partially observable problems. The resulting formal model is called a partially observable Markov decision process or POMDP."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 40,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "7.1",
               "text": "State-Free Deterministic Policies",
               "type": "modelling"
          },
          "paragraphs": [
               "The most naive strategy for dealing with partial observability is to ignore it. That is, to treat the observations as if they were the states of the environment and try to learn to behave. shows a simple environment in which the agent is attempting to get to the printer from an ooce. If it moves from the ooce, there is a good chance that the agent will end up in one of two places that look like but that require diierent actions for getting to the printer. If we consider these states to be the same, then the agent cannot possibly behave optimally. But how w ell can it do?",
               "The resulting problem is not Markovian, and Q-learning cannot be guaranteed to converge. Small breaches of the Markov requirement are well handled by Q-learning, but it is possible to construct simple environments that cause Q-learning to oscillate . It is possible to use a model-based approach, however; act according to some policy and gather statistics about the transitions between observations, then solve for the optimal policy based on those observations. Unfortunately, when the environment i s n o t Markovian, the transition probabilities depend on the policy being executed, so this new policy will induce a new set of transition probabilities. This approach m a y yield plausible results in some cases, but again, there are no guarantees.",
               "It is reasonable, though, to ask what the optimal policy mapping from observations to actions, in this case is. It is NP-hard Littman, 1994b to this mapping, and even the best mapping can have v ery poor performance. In the case of our agent trying to get to the printer, for instance, any deterministic state-free policy takes an innnite number of steps to reach the goal on average."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 41,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "7.2",
               "text": "State-Free Stochastic Policies",
               "type": "modelling"
          },
          "paragraphs": [
               "Some improvement can be gained by considering stochastic policies; these are mappings from observations to probability distributions over actions. If there is randomness in the agent's actions, it will not get stuck in the hall forever. Jaakkola, Singh, and Jordan 1995 have developed an algorithm for locally-optimal stochastic policies, but a globally optimal policy is still NP hard.",
               "In our example, it turns out that the optimal stochastic policy is for the agent, when in a state that looks like a hall, to go east with probability 2 , p 2 0:6 and west with probability p 2 , 1 0:4. This policy can be found by solving a simple in this case quadratic program. The fact that such a simple example can produce irrational numbers gives some indication that it is a diicult problem to solve exactly."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 42,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "7.3",
               "text": "Policies with Internal State",
               "type": "modelling"
          },
          "paragraphs": [
               "The only way to behave truly eeectively in a wide-range of environments is to use memory of previous actions and observations to disambiguate the current state. There are a variety of approaches to learning policies with internal state.",
               "Recurrent Q-learning One intuitively simple approach is to use a recurrent neural network to learn Q values. The network can be trained using backpropagation through time or some other suitable technique and learns to retain features\" to predict value. This approach has been used by a n umber of researchers Meeden, . It seems to work eeectively on simple problems, but can suuer from convergence to local optima on more complex problems.",
               "Classiier Systems were explicitly developed to solve problems with delayed reward, including those requiring short-term memory. The internal mechanism typically used to pass reward back through chains of decisions, called the bucket brigade algorithm, bears a close resemblance to Q-learning. In spite of some early successes, the original design does not appear to handle partially observed environments robustly.",
               "Recently, this approach has been reexamined using insights from the reinforcementlearning literature, with some success. Dorigo did a comparative study of Q-learning and classiier systems . Clii and Ross 1994 start with Wilson's zeroth- level classiier system Wilson, 1995 and add one and two-bit memory registers. They that, although their system can learn to use short-term memory registers eeectively, the approach is unlikely to scale to more complex environments. Dorigo and Colombetti applied classiier systems to a moderately complex problem of learning robot behavior from immediate reinforcement Finite-history-window Approach One way to restore the Markov property is to allow decisions to be based on the history of recent observations and perhaps actions. Lin and Mitchell 1992 used a history window to learn a pole balancing task. McCallum 1995 describes the suux memory\" which learns a variable-width window that serves simultaneously as a model of the environment and a policy. This system has had excellent results in a very complex driving-simulation domain . Ring 1994 has a neural-network approach that uses a variable history window, adding history when necessary to disambiguate situations.",
               "POMDP Approach Another strategy consists of using hidden Markov model HMM techniques to learn a model of the environment, including the hidden state, then to use that model to construct a perfect memory controller Cassandra, Chrisman 1992 showed how the forward-backward algorithm for learning HMMs could be adapted to learning POMDPs. He, and later McCallum 1993, also gave heuristic statesplitting rules to attempt to learn the smallest possible model for a given environment. The resulting model can then be used to integrate information from the agent's observations in order to make decisions. illustrates the basic structure for a perfect-memory controller. The component on the left is the state estimator, which computes the agent's belief state, b as a function of the old belief state, the last action a, and the current observation i. In this context, a belief state is a probability distribution over states of the environment, indicating the likelihood, given the agent's past experience, that the environment is actually in each of those states. The state estimator can be constructed straightforwardly using the estimated world model and Bayes' rule. Now w e are left with the problem of a policy mapping belief states into action. This problem can be formulated as an MDP, but it is diicult to solve using the techniques described earlier, because the input space is continuous. Chrisman's approach 1992 does not take i n to account future uncertainty, but yields a policy after a small amount of computation. A standard approach from the operations-research literature is to solve for the optimal policy or a close approximation thereof based on its representation as a piecewiselinear and convex function over the belief space. This method is computationally intractable, but may serve as inspiration for methods that make further approximations "
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 43,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "8.",
               "text": "Reinforcement Learning Applications",
               "type": "modelling"
          },
          "paragraphs": [
               "One reason that reinforcement learning is popular is that is serves as a theoretical tool for studying the principles of agents learning to act. But it is unsurprising that it has also been used by a n umber of researchers as a practical computational tool for constructing autonomous systems that improve themselves with experience. These applications have ranged from robotics, to industrial manufacturing, to combinatorial search problems such as computer game playing.",
               "Practical applications provide a test of the eecacy and usefulness of learning algorithms. They are also an inspiration for deciding which components of the reinforcement learning framework are of practical importance. For example, a researcher with a real robotic task can provide a data point to questions such as:",
               "How important is optimal exploration? Can we break the learning period into exploration phases and exploitation phases?",
               "What is the most useful model of long-term reward: Finite horizon? Discounted?",
               "Innnite horizon?",
               "How m uch computation is available between agent decisions and how should it be used?",
               "What prior knowledge can we build into the system, and which algorithms are capable of using that knowledge? Let us examine a set of practical applications of reinforcement learning, while bearing these questions in mind."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 44,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "8.1",
               "text": "Game Playing",
               "type": "modelling"
          },
          "paragraphs": [
               "Game playing has dominated the Artiicial Intelligence world as a problem domain ever since the was born. Two-player games do not into the established reinforcement-learning framework since the optimality criterion for games is not one of maximizing reward in the face of a environment, but one of maximizing reward against an optimal adversary minimax. Nonetheless, reinforcement-learning algorithms can be adapted to work for a very general class of games Littman, 1994a and many researchers have used reinforcement learning in these environments. One application, spectacularly far ahead of its time, was Samuel's checkers playing system Samuel, 1959. This learned a value function represented by a linear function approximator, and employed a training scheme similar to the updates used in value iteration, temporal diierences and Q-learning.",
               "More recently,  : TD-Gammon's performance in games against the top human professional players. A backgammon tournament i n volves playing a series of games for points until one player reaches a set target. TD-Gammon won none of these tournaments but came suuciently close that it is now considered one of the best few players in the world."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 45,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "text": "neural network as a function approximator for the value function",
               "type": "modelling"
          },
          "paragraphs": [
               "Board Position ! Probability of victory for current player:",
               "Two v ersions of the learning algorithm were used. The which w e will call Basic TDGammon, used very little predeened knowledge of the game, and the representation of a board position was virtually a raw encoding, suuciently powerful only to permit the neural network to distinguish between conceptually diierent positions. The second, TD-Gammon, was provided with the same raw state information supplemented by a n umber of handcrafted features of backgammon board positions. Providing hand-crafted features in this manner is a good example of how inductive biases from human knowledge of the task can be supplied to a learning algorithm. The training of both learning algorithms required several months of computer time, and was achieved by constant self-play. No exploration strategy was used|the system always greedily chose the move with the largest expected probability of victory. This naive exploration strategy proved entirely adequate for this environment, which is perhaps surprising given the considerable work in the reinforcement-learning literature which has produced numerous counter-examples to show that greedy exploration can lead to poor learning performance. Backgammon, however, has two important properties. Firstly, whatever policy is followed, every game is guaranteed to end in time, meaning that useful reward information is obtained fairly frequently. Secondly, the state transitions are suuciently stochastic that independent of the policy, all states will occasionally be visited|a wrong initial value function has little danger of starving us from visiting a critical part of state space from which important information could be obtained.",
               "The results of TD-Gammon are impressive. It has competed at the very top level of international human play. Basic TD-Gammon played respectably, but not at a professional standard. Although experiments with other games have in some cases produced interesting learning behavior, no success close to that of TD-Gammon has been repeated. Other games that have been studied include Go . It is still an open question as to if and how the success of TD-Gammon can be repeated in other domains."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 46,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "8.2",
               "text": "Robotics and Control",
               "type": "modelling"
          },
          "paragraphs": [
               "In recent y ears there have been many robotics and control applications that have used reinforcement learning. Here we will concentrate on the following four examples, although many other interesting ongoing robotics investigations are underway.",
               "1. Schaal and Atkeson 1994 constructed a two-armed robot, shown in , that learns to juggle a device known as a devil-stick. This is a complex non-linear control task involving a six-dimensional state space and less than 200 msecs per control decision. After about 40 initial attempts the robot learns to keep juggling for hundreds of hits. A typical human learning the task requires an order of magnitude more practice to achieve proociency at mere tens of hits. The juggling robot learned a world model from experience, which w as generalized to unvisited states by a function approximation scheme known as locally weighted regression . Between each trial, a form of dynamic programming speciic to linear control policies and locally linear transitions was used to improve the policy. The form of dynamic programming is known as linear-quadratic-regulator design 2. Mahadevan and Connell 1991a discuss a task in which a mobile robot pushes large boxes for extended periods of time. Box-pushing is a well-known diicult robotics problem, characterized by immense uncertainty in the results of actions. Q-learning was used in conjunction with some novel clustering techniques designed to enable a higher-dimensional input than a tabular approach w ould have permitted. The robot learned to perform competitively with the performance of a human-programmed solution. Another aspect of this work, mentioned in Section 6.3, was a pre-programmed breakdown of the monolithic task description into a set of lower level tasks to be learned.",
               "3. Mataric 1994 describes a robotics experiment with, from the viewpoint of theoretical reinforcement learning, an unthinkably high dimensional state space, containing many dozens of degrees of freedom. Four mobile robots traveled within an enclosure collecting small disks and transporting them to a destination region. There were three enhancements to the basic Q-learning algorithm. Firstly, pre-programmed signals called progress estimators were used to break the monolithic task into subtasks. This was achieved in a robust manner in which the robots were not forced to use the estimators, but had the freedom to proot from the inductive bias they provided. Secondly, control was decentralized. Each robot learned its own policy independently without explicit communication with the others. Thirdly, state space was brutally quantized into a small number of discrete states according to values of a small number of pre-programmed boolean features of the underlying sensors. The performance of the Q-learned policies were almost as good as a simple hand-crafted controller for the job.",
               "4. Q-learning has been used in an elevator dispatching task . The problem, which has been implemented in simulation only at this stage, involved four elevators servicing ten The objective w as to minimize the average squared wait time for passengers, discounted into future time. The problem can be posed as a discrete Markov system, but there are 10 22 states even in the most simpliied version of the problem. Crites and Barto used neural networks for function approximation and provided an excellent comparison study of their Q-learning approach against the most popular and the most sophisticated elevator dispatching algorithms. The squared wait time of their controller was approximately 7 less than the best alternative algorithm Empty the System\" heuristic with a receding horizon controller and less than half the squared wait time of the controller most frequently used in real elevator systems.",
               "5. The example concerns an application of reinforcement learning by one of the authors of this survey to a packaging task from a food processing industry. The problem involves containers with variable numbers of non-identical products. The product characteristics also vary with time, but can be sensed. Depending on the task, various constraints are placed on the container--lling procedure. Here are three examples:",
               "The mean weight of all containers produced by a shift must not be below the manufacturer's declared weight W.",
               "The number of containers below the declared weight m ust be less than P. No containers may be produced below w eight W 0 .",
               "Such tasks are controlled by machinery which operates according to various setpoints. Conventional practice is that setpoints are chosen by h uman operators, but this choice is not easy as it is dependent on the current product characteristics and the current task constraints. The dependency is often diicult to model and highly non-linear. The task was posed as a Markov decision task in which the state of the system is a function of the product characteristics, the amount of time remaining in the production shift and the mean wastage and percent below declared in the shift so far. The system was discretized into 200,000 discrete states and local weighted regression was used to learn and generalize a transition model. Prioritized sweeping was used to maintain an optimal value function as each new piece of transition information was obtained. In simulated experiments the savings were considerable, typically with wastage reduced by a factor of ten. Since then the system has been deployed successfully in several factories within the United States.",
               "Some interesting aspects of practical reinforcement learning come to light from these examples. The most striking is that in all cases, to make a real system work it proved necessary to supplement the fundamental algorithm with extra pre-programmed knowledge. Supplying extra knowledge comes at a price: more human eeort and insight is required and the system is subsequently less autonomous. But it is also clear that for tasks such a s these, a knowledge-free approach w ould not have a c hieved worthwhile performance within the lifetime of the robots.",
               "What forms did this pre-programmed knowledge take? It included an assumption of linearity for the juggling robot's policy, a manual breaking up of the task into subtasks for the two mobile-robot examples, while the box-pusher also used a clustering technique for the Q values which assumed locally consistent Q values. The four disk-collecting robots additionally used a manually discretized state space. The packaging example had far fewer dimensions and so required correspondingly weaker assumptions, but there, too, the assumption of local piecewise continuity in the transition model enabled massive reductions in the amount of learning data required.",
               "The exploration strategies are interesting too. The juggler used careful statistical analysis to judge where to prootably experiment. However, both mobile robot applications were able to learn well with greedy exploration|always exploiting without deliberate exploration. The packaging task used optimism in the face of uncertainty. None of these strategies mirrors theoretically optimal but computationally intractable exploration, and yet all proved adequate.",
               "Finally, it is also worth considering the computational regimes of these experiments. They were all very diierent, which indicates that the diiering computational demands of various reinforcement learning algorithms do indeed have an array of diiering applications. The juggler needed to make v ery fast decisions with low latency between each hit, but had long periods 30 seconds and more between each trial to consolidate the experiences collected on the previous trial and to perform the more aggressive computation necessary to produce a new reactive controller on the next trial. The box-pushing robot was meant t o operate autonomously for hours and so had to make decisions with a uniform length control cycle. The cycle was suuciently long for quite substantial computations beyond simple Qlearning backups. The four disk-collecting robots were particularly interesting. Each robot had a short life of less than 20 minutes due to battery constraints meaning that substantial number crunching was impractical, and any signiicant combinatorial search w ould have used a signiicant fraction of the robot's learning lifetime. The packaging task had easy constraints. One decision was needed every few minutes. This provided opportunities for fully computing the optimal value function for the 200,000-state system between every control cycle, in addition to performing massive cross-validation-based optimization of the transition model being learned.",
               "A great deal of further work is currently in progress on practical implementations of reinforcement learning. The insights and task constraints that they produce will have a n important eeect on shaping the kind of algorithms that are developed in future."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 47,
          "fromPaper": "Reinforcement Learning: A Survey"
     },
     {
          "head": {
               "n": "9.",
               "text": "Conclusions",
               "type": "conclusion"
          },
          "paragraphs": [
               "There are a variety of reinforcement-learning techniques that work eeectively on a variety of small problems. But very few of these techniques scale well to larger problems. This is not because researchers have done a bad job of inventing learning techniques, but because it is very diicult to solve arbitrary problems in the general case. In order to solve highly complex problems, we m ust give u p tabula rasa learning techniques and begin to incorporate bias that will give leverage to the learning process.",
               "The necessary bias can come in a variety of forms, including the following:",
               "shaping: The technique of shaping is used in training animals teacher presents very simple problems to solve then gradually exposes the learner to more complex problems. Shaping has been used in supervised-learning systems, and can be used to train hierarchical reinforcement-learning systems from the bottom up Lin, 1991, and to alleviate problems of delayed reinforcement b y decreasing the delay u n til the problem is well understood local reinforcement signals: Whenever possible, agents should be given reinforcement signals that are local. In applications in which it is possible to compute a gradient, rewarding the agent for taking steps up the gradient, rather than just for achieving the goal, can speed learning signiicantly imitation: An agent can learn by y w atching\" another agent perform the task Lin, 1991.",
               "For real robots, this requires perceptual abilities that are not yet available. But another strategy is to have a h uman supply appropriate motor commands to a robot through a joystick or steering wheel problem decomposition: Decomposing a huge learning problem into a collection of smaller ones, and providing useful reinforcement signals for the subproblems is a very powerful technique for biasing learning. Most interesting examples of robotic reinforcement learning employ this technique to some extent reeexes: One thing that keeps agents that know nothing from learning anything is that they have a hard time even the interesting parts of the space; they wander around at random never getting near the goal, or they are always immediately. These problems can be ameliorated by programming a set of that cause the agent to act initially in some way that is reasonable . These reeexes can eventually be overridden by more detailed and accurate learned knowledge, but they at least keep the agent alive and pointed in the right direction while it is trying to learn. Recent w ork by Millan 1996 explores the use of reeexes to make robot learning safer and more eecient. With appropriate biases, supplied by h uman programmers or teachers, complex reinforcementlearning problems will eventually be solvable. There is still much w ork to be done and many interesting questions remaining for learning techniques and especially regarding methods for approximating, decomposing, and incorporating bias into problems."
          ],
          "paper_id": "23af1da0-97d4-11e8-9580-1f0eb29018a9",
          "paragraphNo": 48,
          "fromPaper": "Reinforcement Learning: A Survey"
     }
]